{"version":3,"sources":["../../src/utils/address.ts"],"sourcesContent":["import SDK from 'js-conflux-sdk';\nimport { getAccount } from './rpcRequest'\n\ninterface AddressCache {\n  [key: string]: any;\n}\nexport const ADDRESS_FUNC_CACHE: AddressCache = {};\n\nexport const isPosAddress = (address: string): boolean => {\n  try {\n    return address.startsWith('0x') && address.length === 66;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const isCfxHexAddress = (address: string): boolean => {\n  const CACHE_KEY = `isCfxHexAddress(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result = SDK.address.isValidCfxHexAddress(address);\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n};\n\nexport const isBase32Address = (address: string): boolean => {\n  const CACHE_KEY = `isBase32Address(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result = SDK.address.isValidCfxAddress(address);\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n};\n\nexport const isSimplyBase32Address = (address: string): boolean => {\n  const CACHE_KEY = `isSimplyBase32Address(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result =\n      SDK.address.isValidCfxAddress(address) &&\n      SDK.address.simplifyCfxAddress(address) === address;\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n};\n\n// support hex and base32\nexport const isAddress = (address: string): boolean => {\n  try {\n    if (address.startsWith('0x')) {\n      return isCfxHexAddress(address);\n    } else {\n      return isBase32Address(address);\n    }\n  } catch (e) {\n    return false;\n  }\n};\n\nexport function isZeroAddress(address: string): boolean {\n  const CACHE_KEY = `isZeroAddress(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result =\n      SDK.address.isZeroAddress(formatAddress(address, 'hex')) ||\n      address === SDK.CONST.ZERO_ADDRESS_HEX ||\n      address === '0x0';\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n}\n\nexport async function isAccountAddress(address: string, space: string): Promise<boolean> {\n  if (space === 'core') {\n    return getAddressInfo(address)?.type === 'user' || isZeroAddress(address);\n  }\n  if (space === 'evm') {\n    try {\n      return (await getAddressType(address)) === 'account';\n    } catch (e) {\n      throw e;\n    }\n  }\n  return false;\n}\n\nexport function isContractAddress(address: string): boolean {\n  return getAddressInfo(address)?.type === 'contract';\n}\n\nexport function isInnerContractAddress(address: string): boolean {\n  const CACHE_KEY = `isInnerContractAddress(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result = SDK.address.isInternalContractAddress(\n      formatAddress(address, 'hex'),\n    );\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n}\n\n// address start with 0x0, not valid internal contract, but fullnode support\nexport function isSpecialAddress(address: string): boolean {\n  const CACHE_KEY = `isSpecialAddress(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result =\n    getAddressInfo(address)?.type === 'builtin' &&\n    !isInnerContractAddress(address);\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n}\n\nexport function isContractCodeHashEmpty(codeHash: string) {\n  return (\n    codeHash ===\n      '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470' ||\n    codeHash === '0x' ||\n    codeHash === ''\n  );\n}\n\nexport async function getAddressType(address: string): Promise<string> {\n  try {\n    const account:any = await getAccount(address);\n    if (isContractCodeHashEmpty(account.codeHash)) {\n      return 'account';\n    }\n    return 'contract';\n  } catch (e) {\n    console.log('getAddressType error: ', e);\n    throw e;\n  }\n}\n\nexport const getAddressInfo = (\n  address: string,\n): {\n  netId: number;\n  type: string;\n  hexAddress: ArrayBuffer | string;\n} | null => {\n  const CACHE_KEY = `getAddressInfo(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = null;\n\n  try {\n    if (isCfxHexAddress(address)) {\n      const base32Address = formatAddress(address, 'base32');\n      result = SDK.address.decodeCfxAddress(base32Address);\n    } else if (isBase32Address(address)) {\n      result = SDK.address.decodeCfxAddress(address);\n    }\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n};\n\nexport const formatAddress = (\n  address: string,\n  outputType = 'base32', // base32 or hex\n): string => {\n  return '';\n};\n"],"mappings":"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","names":[]}