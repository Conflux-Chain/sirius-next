{"version":3,"sources":["../src/utils/address.ts"],"sourcesContent":["import SDK from 'js-conflux-sdk';\nimport lodash from 'lodash';\nimport { getEnvConfig } from '../store';\nimport { getAccount } from './rpcRequest';\nimport { LOCALSTORAGE_KEYS_MAP } from './constants';\n\ninterface AddressCache {\n  [key: string]: any;\n}\nexport const ADDRESS_FUNC_CACHE: AddressCache = {};\n\nexport const isPosAddress = (address: string): boolean => {\n  try {\n    return address.startsWith('0x') && address.length === 66;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const isCfxHexAddress = (address: string): boolean => {\n  const CACHE_KEY = `isCfxHexAddress(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result = SDK.address.isValidCfxHexAddress(address);\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n};\n\nexport const isBase32Address = (address: string): boolean => {\n  const CACHE_KEY = `isBase32Address(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result = SDK.address.isValidCfxAddress(address);\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n};\n\nexport const isSimplyBase32Address = (address: string): boolean => {\n  const CACHE_KEY = `isSimplyBase32Address(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result =\n      SDK.address.isValidCfxAddress(address) &&\n      SDK.address.simplifyCfxAddress(address) === address;\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n};\n\n// support hex and base32\nexport const isAddress = (address: string): boolean => {\n  try {\n    if (address.startsWith('0x')) {\n      return SDK.address.isValidHexAddress(address) || isZeroAddress(address);\n    } else {\n      return isBase32Address(address);\n    }\n  } catch (e) {\n    return false;\n  }\n};\n\nexport function isZeroAddress(address: string): boolean {\n  const CACHE_KEY = `isZeroAddress(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result =\n      SDK.address.isZeroAddress(formatAddress(address, 'hex')) ||\n      address === SDK.CONST.ZERO_ADDRESS_HEX ||\n      address === '0x0';\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n}\n\nexport async function isAccountAddress(\n  address: string,\n  space: string,\n): Promise<boolean> {\n  if (space === 'core') {\n    return getAddressInfo(address)?.type === 'user' || isZeroAddress(address);\n  }\n  if (space === 'evm') {\n    try {\n      return (await getAddressType(address)) === 'account';\n    } catch (e) {\n      throw e;\n    }\n  }\n  return false;\n}\n\nexport function isContractAddress(address: string): boolean {\n  return getAddressInfo(address)?.type === 'contract';\n}\n\nexport function isInnerContractAddress(address: string): boolean {\n  const CACHE_KEY = `isInnerContractAddress(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = false;\n\n  try {\n    result = SDK.address.isInternalContractAddress(\n      formatAddress(address, 'hex'),\n    );\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n}\n\n// address start with 0x0, not valid internal contract, but fullnode support\nexport function isSpecialAddress(address: string): boolean {\n  const CACHE_KEY = `isSpecialAddress(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result =\n    getAddressInfo(address)?.type === 'builtin' &&\n    !isInnerContractAddress(address);\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n}\n\nexport function isContractCodeHashEmpty(codeHash: string) {\n  return (\n    codeHash ===\n      '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470' ||\n    codeHash === '0x' ||\n    codeHash === ''\n  );\n}\n\nexport async function getAddressType(address: string): Promise<string> {\n  try {\n    const account: any = await getAccount(address);\n    if (isContractCodeHashEmpty(account.codeHash)) {\n      return 'account';\n    }\n    return 'contract';\n  } catch (e) {\n    console.log('getAddressType error: ', e);\n    throw e;\n  }\n}\n\nexport const getAddressInfo = (\n  address: string,\n): {\n  netId: number;\n  type: string;\n  hexAddress: ArrayBuffer | string;\n} | null => {\n  const CACHE_KEY = `getAddressInfo(${address})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n  let result = null;\n\n  try {\n    if (isCfxHexAddress(address)) {\n      const base32Address = formatAddress(address, 'base32');\n      result = SDK.address.decodeCfxAddress(base32Address);\n    } else if (isBase32Address(address)) {\n      result = SDK.address.decodeCfxAddress(address);\n    }\n  } catch (e) {}\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n  return result;\n};\n\nexport const NETWORK_ID = (() => {\n  const ENV_CONFIG = getEnvConfig();\n  let networkId = ENV_CONFIG.ENV_NETWORK_ID;\n  let cacheNetworkId = Number(\n    localStorage.getItem(LOCALSTORAGE_KEYS_MAP.networkId),\n  );\n\n  if (lodash.isFinite(cacheNetworkId)) {\n    networkId = Number(cacheNetworkId);\n  }\n  return networkId;\n})();\n\nexport const formatAddress = (address: string, outputType = 'base32') => {\n  const CACHE_KEY = `formatAddress(${address}, ${outputType})`;\n  if (ADDRESS_FUNC_CACHE[CACHE_KEY]) {\n    return ADDRESS_FUNC_CACHE[CACHE_KEY];\n  }\n\n  let result = address;\n\n  try {\n    if (outputType === 'base32') {\n      if (isCfxHexAddress(address)) {\n        result = SDK.format.address(address, NETWORK_ID);\n      } else if (isBase32Address(address)) {\n        const reg = /(.*):(.*):(.*)/;\n        if (reg.test(address)) {\n          result = address.replace(reg, '$1:$3').toLowerCase();\n        }\n      }\n    } else if (outputType === 'hex') {\n      if (isBase32Address(address)) {\n        result = SDK.format.hexAddress(address);\n      }\n    }\n  } catch (error) {\n    console.error('Failed to format address:', error);\n  }\n\n  ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n  return result;\n};\n\n// export const formatAddress = (\n//   address: string,\n//   outputType = 'base32', // base32 or hex\n// ): string => {\n//   const CACHE_KEY = `formatAddress(${address}, ${outputType})`;\n//   if (ADDRESS_FUNC_CACHE[CACHE_KEY]) return ADDRESS_FUNC_CACHE[CACHE_KEY];\n\n//   let result = address;\n\n//   try {\n//     if (outputType === 'base32') {\n//       if (isCfxHexAddress(address)) {\n//         result = SDK.format.address(address, NETWORK_ID);\n//       } else if (isBase32Address(address)) {\n//         const reg = /(.*):(.*):(.*)/;\n//         // compatibility with verbose address, will replace with simply address later\n//         if (typeof address === 'string' && reg.test(address)) {\n//           result = address.replace(reg, '$1:$3').toLowerCase();\n//         }\n//       }\n//     } else if (outputType === 'hex') {\n//       if (isAddress(address)) {\n//         if (outputType === 'hex') {\n//           if (isBase32Address(address)) {\n//             result = SDK.format.hexAddress(address);\n//           } else {\n//             result = address;\n//           }\n//         } else if (outputType === 'base32') {\n//           result = SDK.format.address(address, NETWORK_ID);\n//         } else {\n//           result = address;\n//         }\n//       } else if (isBase32Address(address)) {\n//         if (outputType === 'hex') {\n//           result = SDK.format.hexAddress(address);\n//         } else if (outputType === 'base32') {\n//           const reg = /(.*):(.*):(.*)/;\n//           let lowercaseAddress = address;\n\n//           // compatibility with verbose address, will replace with simply address later\n//           if (typeof address === 'string' && reg.test(address)) {\n//             lowercaseAddress = address.replace(reg, '$1:$3').toLowerCase();\n//           }\n//           result = lowercaseAddress;\n//         } else {\n//           result = address;\n//         }\n//       } else {\n//         result = address;\n//       }\n//     }\n//     ADDRESS_FUNC_CACHE[CACHE_KEY] = result;\n\n//     return result;\n//   } catch (error) {\n\n//   }\n\n//   return result;\n\n// };\n"],"mappings":"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","names":[]}