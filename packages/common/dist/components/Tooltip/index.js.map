{"version":3,"sources":["../../../../../node_modules/.pnpm/@cfx-kit+ui-components@0.0.17_@zag-js+accordion@0.19.1_@zag-js+checkbox@0.19.1_@zag-js+dialog_fmko2yy6bkfybbxu2fwkms7fpm/node_modules/@cfx-kit/ui-components/dist/chunk-G2ADBYYC.js","../../../../../node_modules/.pnpm/@cfx-kit+ui-components@0.0.17_@zag-js+accordion@0.19.1_@zag-js+checkbox@0.19.1_@zag-js+dialog_fmko2yy6bkfybbxu2fwkms7fpm/node_modules/@cfx-kit/ui-components/dist/Tooltip.js","../../../../../node_modules/.pnpm/@zag-js+anatomy@0.19.1/node_modules/@zag-js/anatomy/src/create-anatomy.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/attrs.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/is-html-element.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/contains.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/create-scope.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/env.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/get-active-element.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/get-by-id.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/get-by-text.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/get-by-typeahead.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/get-computed-style.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/get-event-target.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/get-scroll-parent.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/is-editable-element.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/platform.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/query.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/raf.ts","../../../../../node_modules/.pnpm/@zag-js+dom-query@0.19.1/node_modules/@zag-js/dom-query/src/index.ts","../../../../../node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../../../node_modules/.pnpm/@floating-ui+core@1.6.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs","../../../../../node_modules/.pnpm/@floating-ui+dom@1.5.1/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../../../node_modules/.pnpm/@zag-js+utils@0.19.1/node_modules/@zag-js/utils/src/array.ts","../../../../../node_modules/.pnpm/@zag-js+utils@0.19.1/node_modules/@zag-js/utils/src/equal.ts","../../../../../node_modules/.pnpm/@zag-js+utils@0.19.1/node_modules/@zag-js/utils/src/functions.ts","../../../../../node_modules/.pnpm/@zag-js+utils@0.19.1/node_modules/@zag-js/utils/src/guard.ts","../../../../../node_modules/.pnpm/@zag-js+utils@0.19.1/node_modules/@zag-js/utils/src/object.ts","../../../../../node_modules/.pnpm/@zag-js+utils@0.19.1/node_modules/@zag-js/utils/src/warning.ts","../../../../../node_modules/.pnpm/@zag-js+element-rect@0.19.1/node_modules/@zag-js/element-rect/src/index.ts","../../../../../node_modules/.pnpm/@zag-js+popper@0.19.1/node_modules/@zag-js/popper/src/get-placement.ts","../../../../../node_modules/.pnpm/@zag-js+popper@0.19.1/node_modules/@zag-js/popper/src/auto-update.ts","../../../../../node_modules/.pnpm/@zag-js+popper@0.19.1/node_modules/@zag-js/popper/src/middleware.ts","../../../../../node_modules/.pnpm/@zag-js+popper@0.19.1/node_modules/@zag-js/popper/src/get-styles.ts","../../../../../node_modules/.pnpm/proxy-compare@2.5.1/node_modules/proxy-compare/src/index.ts","../../../../../node_modules/.pnpm/@zag-js+store@0.19.1/node_modules/@zag-js/store/src/proxy.ts","../../../../../node_modules/.pnpm/@zag-js+store@0.19.1/node_modules/@zag-js/store/src/proxy-computed.ts","../../../../../node_modules/.pnpm/@zag-js+store@0.19.1/node_modules/@zag-js/store/src/subscribe-key.ts","../../../../../node_modules/.pnpm/klona@2.0.6/node_modules/klona/full/index.mjs","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/index.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/utilities/core/src/array.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/utilities/core/src/functions.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/utilities/core/src/guard.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/utilities/core/src/object.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/utilities/core/src/warning.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/deep-merge.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/utils.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/guard-utils.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/machine.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/create-proxy.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/delay-utils.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/transition-utils.ts","../../../../../node_modules/.pnpm/@zag-js+core@0.19.1/node_modules/@zag-js/core/src/merge-props.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/add-dom-event.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/assertion.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/fire-event.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/get-event-key.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/get-event-point.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/get-event-step.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/get-native-event.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/get-point-value.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/request-pointer-lock.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/track-pointer-move.ts","../../../../../node_modules/.pnpm/@zag-js+dom-event@0.19.1/node_modules/@zag-js/dom-event/src/track-visual-viewport.ts","../../../../../node_modules/.pnpm/@zag-js+tooltip@0.19.1/node_modules/@zag-js/tooltip/src/tooltip.anatomy.ts","../../../../../node_modules/.pnpm/@zag-js+tooltip@0.19.1/node_modules/@zag-js/tooltip/src/tooltip.connect.ts","../../../../../node_modules/.pnpm/@zag-js+tooltip@0.19.1/node_modules/@zag-js/tooltip/src/tooltip.dom.ts","../../../../../node_modules/.pnpm/@zag-js+tooltip@0.19.1/node_modules/@zag-js/tooltip/src/tooltip.store.ts","../../../../../node_modules/.pnpm/@zag-js+tooltip@0.19.1/node_modules/@zag-js/tooltip/src/tooltip.machine.ts","../../../../../node_modules/.pnpm/@zag-js+types@0.19.1/node_modules/@zag-js/types/src/prop-types.ts","../../../../../node_modules/.pnpm/@zag-js+react@0.19.1_react-dom@18.2.0_react@18.2.0/node_modules/@zag-js/react/src/index.ts","../../../../../node_modules/.pnpm/@zag-js+react@0.19.1_react-dom@18.2.0_react@18.2.0/node_modules/@zag-js/react/src/normalize-props.ts","../../../../../node_modules/.pnpm/@zag-js+react@0.19.1_react-dom@18.2.0_react@18.2.0/node_modules/@zag-js/react/src/portal.ts","../../../../../node_modules/.pnpm/@zag-js+react@0.19.1_react-dom@18.2.0_react@18.2.0/node_modules/@zag-js/react/src/use-layout-effect.ts","../../../../../node_modules/.pnpm/@zag-js+react@0.19.1_react-dom@18.2.0_react@18.2.0/node_modules/@zag-js/react/src/use-snapshot.ts","../../../../../node_modules/.pnpm/@zag-js+react@0.19.1_react-dom@18.2.0_react@18.2.0/node_modules/@zag-js/react/src/use-actor.ts","../../../../../node_modules/.pnpm/@zag-js+react@0.19.1_react-dom@18.2.0_react@18.2.0/node_modules/@zag-js/react/src/use-constant.ts","../../../../../node_modules/.pnpm/@zag-js+react@0.19.1_react-dom@18.2.0_react@18.2.0/node_modules/@zag-js/react/src/use-machine.ts","../../../src/components/Tooltip/index.tsx"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\nexport {\n  __spreadValues,\n  __spreadProps,\n  __objRest\n};\n","import {\n  __objRest,\n  __spreadProps,\n  __spreadValues\n} from \"./chunk-G2ADBYYC.js\";\n\n// src/Tooltip/index.tsx\nimport { useEffect, useId, isValidElement, cloneElement, Children } from \"react\";\nimport { machine, connect } from \"@zag-js/tooltip\";\nimport { useMachine, normalizeProps } from \"@zag-js/react\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar Tooltip = (_a) => {\n  var _b = _a, {\n    id,\n    open = false,\n    openDelay = 200,\n    closeDelay = 200,\n    arrow = true,\n    positioning,\n    children,\n    containerClassName,\n    trigger\n  } = _b, props = __objRest(_b, [\n    \"id\",\n    \"open\",\n    \"openDelay\",\n    \"closeDelay\",\n    \"arrow\",\n    \"positioning\",\n    \"children\",\n    \"containerClassName\",\n    \"trigger\"\n  ]);\n  const uniqueId = useId();\n  const [state, send] = useMachine(machine(__spreadValues({ id: id != null ? id : uniqueId, openDelay, closeDelay, positioning }, props)));\n  const api = connect(state, send, normalizeProps);\n  useEffect(() => {\n    if (open === true) {\n      api.open();\n    } else {\n      api.close();\n    }\n  }, [open]);\n  return /* @__PURE__ */ jsxs(Fragment, { children: [\n    typeof trigger === \"function\" ? trigger({ triggerProps: api.triggerProps }) : null,\n    api.isOpen && /* @__PURE__ */ jsxs(\"div\", __spreadProps(__spreadValues({ className: `ui-tooltip${containerClassName ? ` ${containerClassName}` : \"\"}` }, api.positionerProps), { children: [\n      arrow && /* @__PURE__ */ jsx(\"div\", __spreadProps(__spreadValues({}, api.arrowProps), { children: /* @__PURE__ */ jsx(\"div\", __spreadValues({}, api.arrowTipProps)) })),\n      typeof children === \"function\" && children({ contentProps: api.contentProps }),\n      typeof children !== \"function\" ? Children.count(children) === 1 && isValidElement(children) ? cloneElement(children, __spreadValues({}, api.contentProps)) : /* @__PURE__ */ jsx(\"div\", __spreadProps(__spreadValues({}, api.contentProps), { children })) : null\n    ] }))\n  ] });\n};\nvar Tooltip_default = Tooltip;\nexport {\n  Tooltip_default as default\n};\n","export interface AnatomyPart {\n  selector: string\n  attrs: Record<\"data-scope\" | \"data-part\", string>\n}\n\nexport type AnatomyInstance<T extends string> = Omit<Anatomy<T>, \"parts\">\n\nexport type AnatomyPartName<T> = T extends AnatomyInstance<infer U> ? U : never\n\nexport interface Anatomy<T extends string> {\n  parts: <U extends string>(...parts: U[]) => AnatomyInstance<U>\n  extendWith: <V extends string>(...parts: V[]) => AnatomyInstance<T | V>\n  build: () => Record<T, AnatomyPart>\n  rename: (newName: string) => Anatomy<T>\n  keys: () => T[]\n}\n\nexport const createAnatomy = <T extends string>(name: string, parts = [] as T[]): Anatomy<T> => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values)\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\")\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  rename: (newName) => createAnatomy(newName, parts),\n  keys: () => parts,\n  build: () =>\n    [...new Set(parts)].reduce<Record<string, AnatomyPart>>(\n      (prev, part) =>\n        Object.assign(prev, {\n          [part]: {\n            selector: [\n              `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n              `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n            ].join(\", \"),\n            attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) },\n          },\n        }),\n      {},\n    ),\n})\n\nconst toKebabCase = (value: string) =>\n  value\n    .replace(/([A-Z])([A-Z])/g, \"$1-$2\")\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/[\\s_]+/g, \"-\")\n    .toLowerCase()\n\nconst isEmpty = <T>(v: T[]): boolean => v.length === 0\n","type Booleanish = boolean | \"true\" | \"false\"\n\nexport const dataAttr = (guard: boolean | undefined) => {\n  return (guard ? \"\" : undefined) as Booleanish\n}\n\nexport const ariaAttr = (guard: boolean | undefined) => {\n  return guard ? \"true\" : undefined\n}\n","export function isHTMLElement(value: any): value is HTMLElement {\n  return typeof value === \"object\" && value?.nodeType === Node.ELEMENT_NODE && typeof value?.nodeName === \"string\"\n}\n","import { isHTMLElement } from \"./is-html-element\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n\nexport const isSelfEvent = (event: Pick<UIEvent, \"currentTarget\" | \"target\">) =>\n  contains(event.currentTarget, event.target)\n","type Ctx = { getRootNode?: () => Document | ShadowRoot | Node }\n\nconst getDocument = (node: Document | ShadowRoot | Node) => {\n  if (node.nodeType === Node.DOCUMENT_NODE) return node as Document\n  return node.ownerDocument ?? document\n}\n\nexport function createScope<T>(methods: T) {\n  const screen = {\n    getRootNode: (ctx: Ctx) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: Ctx) => getDocument(screen.getRootNode(ctx)),\n    getWin: (ctx: Ctx) => screen.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: Ctx) => screen.getDoc(ctx).activeElement as HTMLElement | null,\n    getById: <T extends HTMLElement = HTMLElement>(ctx: Ctx, id: string) =>\n      screen.getRootNode(ctx).getElementById(id) as T | null,\n    setValue: <T extends { value: string }>(elem: T | null, value: string | number | null | undefined) => {\n      if (elem == null || value == null) return\n      elem.value = value.toString()\n    },\n  }\n  return { ...screen, ...methods }\n}\n","const isDocument = (el: any): el is Document => el.nodeType === Node.DOCUMENT_NODE\n\nexport function getDocument(el: Element | Node | Document | null) {\n  if (isDocument(el)) return el\n  return el?.ownerDocument ?? document\n}\n\nexport function getWindow(el: HTMLElement) {\n  return el?.ownerDocument.defaultView ?? window\n}\n","export function getActiveElement(el: HTMLElement): HTMLElement | null {\n  let activeElement = el.ownerDocument.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n","export function itemById<T extends HTMLElement>(v: T[], id: string) {\n  return v.find((node) => node.id === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string) {\n  const item = itemById(v, id)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n","import { indexOfId } from \"./get-by-id\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => item.dataset.valuetext ?? item.textContent ?? \"\"\n\nconst match = (valueText: string, query: string) => valueText.toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(v: T[], text: string, currentId?: string | null) {\n  const index = currentId ? indexOfId(v, currentId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => item.id !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n","import { getByText } from \"./get-by-text\"\n\nexport type TypeaheadState = {\n  keysSoFar: string\n  timer: number\n}\n\nexport type TypeaheadOptions = {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350 } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n","const styleCache = new WeakMap<HTMLElement, any>()\n\nexport function getComputedStyle(el: HTMLElement) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window\n    styleCache.set(el, win.getComputedStyle(el))\n  }\n  return styleCache.get(el)\n}\n","export function getEventTarget<T extends EventTarget>(event: Event): T | null {\n  return (event.composedPath?.()[0] ?? event.target) as T | null\n}\n","import { isHTMLElement } from \"./is-html-element\"\n\nfunction isScrollParent(el: HTMLElement): boolean {\n  const win = el.ownerDocument.defaultView || window\n  const { overflow, overflowX, overflowY } = win.getComputedStyle(el)\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)\n}\n\nexport function getParent(el: HTMLElement): HTMLElement {\n  if (el.localName === \"html\") return el\n  return el.assignedSlot || el.parentElement || el.ownerDocument.documentElement\n}\n\nexport function getScrollParent(el: HTMLElement): HTMLElement {\n  if ([\"html\", \"body\", \"#document\"].includes(el.localName)) {\n    return el.ownerDocument.body\n  }\n\n  if (isHTMLElement(el) && isScrollParent(el)) {\n    return el\n  }\n\n  return getScrollParent(getParent(el))\n}\n\ntype Target = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getScrollParents(el: HTMLElement, list: Target = []): Target {\n  const parent = getScrollParent(el)\n  const isBody = parent === el.ownerDocument.body\n  const win = parent.ownerDocument.defaultView || window\n\n  //@ts-expect-error\n  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(parent) ? parent : []) : parent\n\n  const parents = list.concat(target)\n  return isBody ? parents : parents.concat(getScrollParents(getParent(<HTMLElement>target)))\n}\n","import { isHTMLElement } from \"./is-html-element\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = el.ownerDocument.defaultView || window\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n","export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/) && !isTouchDevice()\nexport const isIPhone = () => pt(/^iPhone/)\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => isApple() && !isMac()\n","type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends HTMLElement = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends HTMLElement = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector)\n}\n","export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n","export * from \"./attrs\"\nexport * from \"./contains\"\nexport * from \"./create-scope\"\nexport * from \"./env\"\nexport * from \"./get-active-element\"\nexport * from \"./get-by-id\"\nexport * from \"./get-by-text\"\nexport * from \"./get-by-typeahead\"\nexport * from \"./get-computed-style\"\nexport * from \"./get-event-target\"\nexport * from \"./get-scroll-parent\"\nexport * from \"./is-editable-element\"\nexport * from \"./is-html-element\"\nexport * from \"./platform\"\nexport * from \"./query\"\nexport * from \"./raf\"\n\nexport const MAX_Z_INDEX = 2147483647\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n","export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => removeAt(v, v.indexOf(item))\n\nexport const removeAt = <T>(v: T[], i: number): T[] => {\n  if (i > -1) v.splice(i, 1)\n  return v\n}\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n","export const isEqual = (a: any, b: any) => {\n  if (Object.is(a, b)) return true\n\n  if (!(a instanceof Object) || !(b instanceof Object)) return false\n\n  const keys = Object.keys(a)\n  const length = keys.length\n\n  for (let i = 0; i < length; i++) {\n    if (!(keys[i] in b)) return false\n  }\n\n  for (let i = 0; i < length; i++) {\n    if (a[keys[i]] !== b[keys[i]]) return false\n  }\n\n  return length === Object.keys(b).length\n}\n","export const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n","export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n","export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n","export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n","type Fn = (rect: Rect) => void\n\ntype Rect = {\n  top: number\n  left: number\n  width: number\n  height: number\n}\n\ntype ObservedData = {\n  rect: Rect\n  callbacks: Fn[]\n}\n\nlet rafId: number\n\nconst observedElements = new Map<HTMLElement, ObservedData>()\n\ntype TrackScope = \"size\" | \"position\" | \"rect\"\n\nexport type ElementRectOptions = {\n  onChange: (rect: Rect) => void\n  scope?: TrackScope\n  getRect?: (el: HTMLElement) => Rect\n}\n\nconst getRectFn = (el: HTMLElement) => el.getBoundingClientRect()\n\nexport function trackElementRect(el: HTMLElement, options: ElementRectOptions) {\n  const { scope = \"rect\", getRect = getRectFn, onChange } = options\n  const loop = getLoopFn({ scope, getRect })\n\n  const data = observedElements.get(el)\n\n  if (!data) {\n    observedElements.set(el, {\n      rect: {} as Rect,\n      callbacks: [onChange],\n    })\n\n    if (observedElements.size === 1) {\n      rafId = requestAnimationFrame(loop)\n    }\n  } else {\n    data.callbacks.push(onChange)\n    onChange(getRect(el))\n  }\n\n  return function unobserve() {\n    const data = observedElements.get(el)\n    if (!data) return\n\n    const index = data.callbacks.indexOf(onChange)\n    if (index > -1) {\n      data.callbacks.splice(index, 1)\n    }\n\n    if (data.callbacks.length === 0) {\n      observedElements.delete(el)\n\n      if (observedElements.size === 0) {\n        cancelAnimationFrame(rafId)\n      }\n    }\n  }\n}\n\nfunction getLoopFn(options: Required<Omit<ElementRectOptions, \"onChange\">>) {\n  const { scope, getRect } = options\n  const isEqual = getEqualityFn(scope)\n  return function loop() {\n    const changedRectsData: Array<ObservedData> = []\n\n    observedElements.forEach((data, element) => {\n      const newRect = getRect(element)\n\n      if (!isEqual(data.rect, newRect)) {\n        data.rect = newRect\n        changedRectsData.push(data)\n      }\n    })\n\n    changedRectsData.forEach((data) => {\n      data.callbacks.forEach((callback) => callback(data.rect))\n    })\n\n    rafId = requestAnimationFrame(loop)\n  }\n}\n\nconst isEqualSize = (a: Rect, b: Rect) => a.width === b.width && a.height === b.height\n\nconst isEqualPosition = (a: Rect, b: Rect) => a.top === b.top && a.left === b.left\n\nconst isEqualRect = (a: Rect, b: Rect) => isEqualSize(a, b) && isEqualPosition(a, b)\n\nfunction getEqualityFn(scope: TrackScope) {\n  if (scope === \"size\") return isEqualSize\n  if (scope === \"position\") return isEqualPosition\n  return isEqualRect\n}\n","import type { Middleware, Placement, VirtualElement } from \"@floating-ui/dom\"\nimport { type ComputePositionConfig, arrow, computePosition, flip, offset, shift, size } from \"@floating-ui/dom\"\nimport { raf } from \"@zag-js/dom-query\"\nimport { callAll, compact } from \"@zag-js/utils\"\nimport { autoUpdate } from \"./auto-update\"\nimport { shiftArrow, transformOrigin } from \"./middleware\"\nimport type { BasePlacement, PositioningOptions } from \"./types\"\n\nconst defaultOptions: PositioningOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  sameWidth: false,\n  overflowPadding: 8,\n}\n\ntype MaybeRectElement = HTMLElement | VirtualElement | null\ntype MaybeElement = HTMLElement | null\ntype MaybeFn<T> = T | (() => T)\n\nfunction getPlacementImpl(reference: MaybeRectElement, floating: MaybeElement, opts: PositioningOptions = {}) {\n  if (!floating || !reference) return\n\n  const options = Object.assign({}, defaultOptions, opts)\n\n  /* -----------------------------------------------------------------------------\n   * The middleware stack\n   * -----------------------------------------------------------------------------*/\n\n  const arrowEl = floating.querySelector<HTMLElement>(\"[data-part=arrow]\")\n  const middleware: Middleware[] = []\n\n  const boundary = typeof options.boundary === \"function\" ? options.boundary() : options.boundary\n\n  if (options.flip) {\n    middleware.push(\n      flip({\n        boundary,\n        padding: options.overflowPadding,\n      }),\n    )\n  }\n\n  if (options.gutter || options.offset) {\n    const arrowOffset = arrowEl ? arrowEl.offsetHeight / 2 : 0\n\n    let mainAxis = options.offset?.mainAxis ?? options.gutter\n    let crossAxis = options.offset?.crossAxis\n\n    if (mainAxis != null) mainAxis += arrowOffset\n\n    const offsetOptions = compact({ mainAxis, crossAxis })\n    middleware.push(offset(offsetOptions))\n  }\n\n  middleware.push(\n    shift({\n      boundary,\n      crossAxis: options.overlap,\n      padding: options.overflowPadding,\n    }),\n  )\n\n  if (arrowEl) {\n    // prettier-ignore\n    middleware.push(\n      arrow({ element: arrowEl, padding: 8 }),\n      shiftArrow({ element: arrowEl }),\n    )\n  }\n\n  middleware.push(transformOrigin)\n\n  middleware.push(\n    size({\n      padding: options.overflowPadding,\n      apply({ rects, availableHeight, availableWidth }) {\n        const referenceWidth = Math.round(rects.reference.width)\n        floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`)\n        floating.style.setProperty(\"--available-width\", `${availableWidth}px`)\n        floating.style.setProperty(\"--available-height\", `${availableHeight}px`)\n      },\n    }),\n  )\n\n  /* -----------------------------------------------------------------------------\n   * The actual positioning function\n   * -----------------------------------------------------------------------------*/\n\n  function compute(config: Omit<ComputePositionConfig, \"platform\"> = {}) {\n    if (!reference || !floating) return\n    const { placement, strategy, onComplete } = options\n\n    computePosition(reference, floating, {\n      placement,\n      middleware,\n      strategy,\n      ...config,\n    }).then((data) => {\n      const x = Math.round(data.x)\n      floating.style.setProperty(\"--x\", `${x}px`)\n\n      const y = Math.round(data.y)\n      floating.style.setProperty(\"--y\", `${y}px`)\n\n      onComplete?.(data)\n    })\n  }\n\n  compute()\n\n  return callAll(\n    options.listeners ? autoUpdate(reference, floating, compute, options.listeners) : undefined,\n    options.onCleanup,\n  )\n}\n\nexport function getBasePlacement(placement: Placement): BasePlacement {\n  return placement.split(\"-\")[0] as BasePlacement\n}\n\nexport function getPlacement(\n  referenceOrFn: MaybeFn<MaybeRectElement>,\n  floatingOrFn: MaybeFn<MaybeElement>,\n  opts: PositioningOptions & { defer?: boolean } = {},\n) {\n  const { defer, ...restOptions } = opts\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const reference = typeof referenceOrFn === \"function\" ? referenceOrFn() : referenceOrFn\n      const floating = typeof floatingOrFn === \"function\" ? floatingOrFn() : floatingOrFn\n      cleanups.push(getPlacementImpl(reference, floating, restOptions))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","import type { Placement, ReferenceElement } from \"@floating-ui/dom\"\nimport { getOverflowAncestors } from \"@floating-ui/dom\"\nimport { trackElementRect } from \"@zag-js/element-rect\"\n\nexport type { Placement }\n\nexport type AutoUpdateOptions = {\n  ancestorScroll?: boolean\n  ancestorResize?: boolean\n  referenceResize?: boolean\n}\n\ntype Ancestors = ReturnType<typeof getOverflowAncestors>\n\nconst callAll =\n  (...fns: VoidFunction[]) =>\n  () =>\n    fns.forEach((fn) => fn())\n\nconst isHTMLElement = (el: any): el is HTMLElement => {\n  return typeof el === \"object\" && el !== null && el.nodeType === 1\n}\n\nconst addDomEvent = (el: HTMLElement, type: string, fn: VoidFunction, options?: boolean | AddEventListenerOptions) => {\n  el.addEventListener(type, fn, options)\n  return () => el.removeEventListener(type, fn, options)\n}\n\nfunction resolveOptions(option: boolean | AutoUpdateOptions) {\n  const bool = typeof option === \"boolean\"\n  return {\n    ancestorResize: bool ? option : option.ancestorResize ?? true,\n    ancestorScroll: bool ? option : option.ancestorScroll ?? true,\n    referenceResize: bool ? option : option.referenceResize ?? true,\n  }\n}\n\nexport function autoUpdate(\n  reference: ReferenceElement,\n  floating: HTMLElement,\n  update: () => void,\n  options: boolean | AutoUpdateOptions = false,\n) {\n  const { ancestorScroll, ancestorResize, referenceResize } = resolveOptions(options)\n\n  const useAncestors = ancestorScroll || ancestorResize\n  const ancestors: Ancestors = []\n\n  if (useAncestors && isHTMLElement(reference)) {\n    ancestors.push(...getOverflowAncestors(reference))\n  }\n\n  function addResizeListeners() {\n    let cleanups: VoidFunction[] = [trackElementRect(floating, { scope: \"size\", onChange: update })]\n    if (referenceResize && isHTMLElement(reference)) {\n      cleanups.push(trackElementRect(reference, { onChange: update }))\n    }\n    cleanups.push(callAll(...ancestors.map((el: any) => addDomEvent(el, \"resize\", update))))\n    return () => cleanups.forEach((fn) => fn())\n  }\n\n  function addScrollListeners() {\n    return callAll(...ancestors.map((el: any) => addDomEvent(el, \"scroll\", update, { passive: true })))\n  }\n\n  return callAll(addResizeListeners(), addScrollListeners())\n}\n","import type { Coords, Middleware } from \"@floating-ui/dom\"\n\n/* -----------------------------------------------------------------------------\n * Shared middleware utils\n * -----------------------------------------------------------------------------*/\n\nconst toVar = (value: string) => ({ variable: value, reference: `var(${value})` })\n\nexport const cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\"),\n}\n\n/* -----------------------------------------------------------------------------\n * Transform Origin Middleware\n * -----------------------------------------------------------------------------*/\n\nconst getTransformOrigin = (arrow?: Partial<Coords>) => ({\n  top: \"bottom center\",\n  \"top-start\": arrow ? `${arrow.x}px bottom` : \"left bottom\",\n  \"top-end\": arrow ? `${arrow.x}px bottom` : \"right bottom\",\n  bottom: \"top center\",\n  \"bottom-start\": arrow ? `${arrow.x}px top` : \"top left\",\n  \"bottom-end\": arrow ? `${arrow.x}px top` : \"top right\",\n  left: \"right center\",\n  \"left-start\": arrow ? `right ${arrow.y}px` : \"right top\",\n  \"left-end\": arrow ? `right ${arrow.y}px` : \"right bottom\",\n  right: \"left center\",\n  \"right-start\": arrow ? `left ${arrow.y}px` : \"left top\",\n  \"right-end\": arrow ? `left ${arrow.y}px` : \"left bottom\",\n})\n\nexport const transformOrigin: Middleware = {\n  name: \"transformOrigin\",\n  fn({ placement, elements, middlewareData }) {\n    const { arrow } = middlewareData\n    const transformOrigin = getTransformOrigin(arrow)[placement]\n\n    const { floating } = elements\n    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin)\n\n    return {\n      data: { transformOrigin },\n    }\n  },\n}\n\n/* -----------------------------------------------------------------------------\n * Arrow Middleware\n * -----------------------------------------------------------------------------*/\n\ntype ArrowOptions = { element: HTMLElement }\n\ntype BasePlacement = \"top\" | \"bottom\" | \"left\" | \"right\"\n\nexport const shiftArrow = (opts: ArrowOptions): Middleware => ({\n  name: \"shiftArrow\",\n  fn({ placement, middlewareData }) {\n    const { element: arrow } = opts\n\n    if (middlewareData.arrow) {\n      const { x, y } = middlewareData.arrow\n\n      const dir = placement.split(\"-\")[0] as BasePlacement\n\n      Object.assign(arrow.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`,\n      })\n    }\n\n    return {}\n  },\n})\n","import type { Placement } from \"@floating-ui/dom\"\nimport { cssVars } from \"./middleware\"\nimport type { PositioningOptions } from \"./types\"\n\nexport type GetPlacementStylesOptions = {\n  placement?: Placement\n}\n\nconst ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\",\n} as const\n\nexport function getPlacementStyles(options: PositioningOptions = {}) {\n  const { placement = \"bottom\", sameWidth, fitViewport, strategy = \"absolute\" } = options\n\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`,\n    } as const,\n\n    arrowTip: {\n      transform: ARROW_FLOATING_STYLE[placement.split(\"-\")[0]],\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\",\n    } as const,\n\n    floating: {\n      position: strategy,\n      minWidth: sameWidth ? undefined : \"max-content\",\n      width: sameWidth ? \"var(--reference-width)\" : undefined,\n      maxWidth: fitViewport ? \"var(--available-width)\" : undefined,\n      maxHeight: fitViewport ? \"var(--available-height)\" : undefined,\n      top: \"0px\",\n      left: \"0px\",\n      transform: `translate3d(var(--x), var(--y), 0)`,\n    } as const,\n  }\n}\n","// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n\n// function to create a new bare proxy\nlet newProxy = <T extends object>(\n  target: T,\n  handler: ProxyHandler<T>,\n) => new Proxy(target, handler);\n\n// get object prototype\nconst getProto = Object.getPrototypeOf;\n\nconst objectsToTrack = new WeakMap<object, boolean>();\n\n// check if obj is a plain object or an array\nconst isObjectToTrack = <T>(obj: T): obj is T extends object ? T : never => (\n  obj && (objectsToTrack.has(obj as unknown as object)\n    ? objectsToTrack.get(obj as unknown as object) as boolean\n    : (getProto(obj) === Object.prototype || getProto(obj) === Array.prototype)\n  )\n);\n\n// check if it is object\nconst isObject = (x: unknown): x is object => (\n  typeof x === 'object' && x !== null\n);\n\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj: object) => (\n  Object.values(Object.getOwnPropertyDescriptors(obj)).some(\n    (descriptor) => !descriptor.configurable && !descriptor.writable,\n  )\n);\n\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = <T extends object>(obj: T): T => {\n  if (Array.isArray(obj)) {\n    // Arrays need a special way to copy\n    return Array.from(obj) as T;\n  }\n  // For non-array objects, we create a new object keeping the prototype\n  // with changing all configurable options (otherwise, proxies will complain)\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  Object.values(descriptors).forEach((desc) => { desc.configurable = true; });\n  return Object.create(getProto(obj), descriptors);\n};\n\ntype HasKeySet = Set<string | symbol>\ntype HasOwnKeySet = Set<string | symbol>\ntype KeysSet = Set<string | symbol>\ntype Used = {\n  [HAS_KEY_PROPERTY]?: HasKeySet;\n  [ALL_OWN_KEYS_PROPERTY]?: true;\n  [HAS_OWN_KEY_PROPERTY]?: HasOwnKeySet;\n  [KEYS_PROPERTY]?: KeysSet;\n};\ntype Affected = WeakMap<object, Used>;\ntype ProxyHandlerState<T extends object> = {\n  readonly [IS_TARGET_COPIED_PROPERTY]: boolean;\n  [PROXY_PROPERTY]?: T;\n  [PROXY_CACHE_PROPERTY]?: ProxyCache<object> | undefined;\n  [TARGET_CACHE_PROPERTY]?: TargetCache<object> | undefined;\n  [AFFECTED_PROPERTY]?: Affected;\n}\ntype ProxyCache<T extends object> = WeakMap<\n  object,\n  readonly [ProxyHandler<T>, ProxyHandlerState<T>]\n>;\ntype TargetCache<T extends object> = WeakMap<\n  object,\n  readonly [target: T, copiedTarget?: T]\n>;\n\nconst createProxyHandler = <T extends object>(origObj: T, isTargetCopied: boolean) => {\n  const state: ProxyHandlerState<T> = {\n    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n  };\n  let trackObject = false; // for trackMemo\n  const recordUsage = (\n    type:\n      | typeof HAS_KEY_PROPERTY\n      | typeof ALL_OWN_KEYS_PROPERTY\n      | typeof HAS_OWN_KEY_PROPERTY\n      | typeof KEYS_PROPERTY,\n    key?: string | symbol,\n  ) => {\n    if (!trackObject) {\n      let used = (state[AFFECTED_PROPERTY] as Affected).get(origObj);\n      if (!used) {\n        used = {};\n        (state[AFFECTED_PROPERTY] as Affected).set(origObj, used);\n      }\n      if (type === ALL_OWN_KEYS_PROPERTY) {\n        used[ALL_OWN_KEYS_PROPERTY] = true;\n      } else {\n        let set = used[type];\n        if (!set) {\n          set = new Set();\n          used[type] = set;\n        }\n        set.add(key as string | symbol);\n      }\n    }\n  };\n  const recordObjectAsUsed = () => {\n    trackObject = true;\n    (state[AFFECTED_PROPERTY] as Affected).delete(origObj);\n  };\n  const handler: ProxyHandler<T> = {\n    get(target, key) {\n      if (key === GET_ORIGINAL_SYMBOL) {\n        return origObj;\n      }\n      recordUsage(KEYS_PROPERTY, key);\n      return createProxy(\n        Reflect.get(target, key),\n        (state[AFFECTED_PROPERTY] as Affected),\n        state[PROXY_CACHE_PROPERTY],\n        state[TARGET_CACHE_PROPERTY],\n      );\n    },\n    has(target, key) {\n      if (key === TRACK_MEMO_SYMBOL) {\n        recordObjectAsUsed();\n        return true;\n      }\n      recordUsage(HAS_KEY_PROPERTY, key);\n      return Reflect.has(target, key);\n    },\n    getOwnPropertyDescriptor(target, key) {\n      recordUsage(HAS_OWN_KEY_PROPERTY, key);\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    },\n    ownKeys(target) {\n      recordUsage(ALL_OWN_KEYS_PROPERTY);\n      return Reflect.ownKeys(target);\n    },\n  };\n  if (isTargetCopied) {\n    handler.set = handler.deleteProperty = () => false;\n  }\n  return [handler, state] as const;\n};\n\nconst getOriginalObject = <T extends object>(obj: T) => (\n  // unwrap proxy\n  (obj as { [GET_ORIGINAL_SYMBOL]?: typeof obj })[GET_ORIGINAL_SYMBOL]\n  // otherwise\n  || obj\n);\n\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = <T>(\n  obj: T,\n  affected: WeakMap<object, unknown>,\n  proxyCache?: WeakMap<object, unknown>,\n  targetCache?: WeakMap<object, unknown>,\n): T => {\n  if (!isObjectToTrack(obj)) return obj;\n  let targetAndCopied = (\n    targetCache && (targetCache as TargetCache<typeof obj>).get(obj)\n  );\n  if (!targetAndCopied) {\n    const target = getOriginalObject(obj);\n    if (needsToCopyTargetObject(target)) {\n      targetAndCopied = [target, copyTargetObject(target)];\n    } else {\n      targetAndCopied = [target];\n    }\n    targetCache?.set(obj, targetAndCopied);\n  }\n  const [target, copiedTarget] = targetAndCopied;\n  let handlerAndState = (\n    proxyCache && (proxyCache as ProxyCache<typeof target>).get(target)\n  );\n  if (\n    !handlerAndState\n    || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget\n  ) {\n    handlerAndState = createProxyHandler<typeof target>(target, !!copiedTarget);\n    handlerAndState[1][PROXY_PROPERTY] = newProxy(\n      copiedTarget || target,\n      handlerAndState[0],\n    );\n    if (proxyCache) {\n      proxyCache.set(target, handlerAndState);\n    }\n  }\n  handlerAndState[1][AFFECTED_PROPERTY] = affected as Affected;\n  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache as ProxyCache<object> | undefined;\n  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache as TargetCache<object> | undefined;\n  return handlerAndState[1][PROXY_PROPERTY] as typeof target;\n};\n\nconst isAllOwnKeysChanged = (prevObj: object, nextObj: object) => {\n  const prevKeys = Reflect.ownKeys(prevObj);\n  const nextKeys = Reflect.ownKeys(nextObj);\n  return prevKeys.length !== nextKeys.length\n    || prevKeys.some((k, i) => k !== nextKeys[i]);\n};\n\ntype ChangedCache = WeakMap<object, {\n  [NEXT_OBJECT_PROPERTY]: object;\n  [CHANGED_PROPERTY]: boolean;\n}>;\n\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\n\nexport const isChanged = (\n  prevObj: unknown,\n  nextObj: unknown,\n  affected: WeakMap<object, unknown>,\n  cache?: WeakMap<object, unknown>,\n): boolean => {\n  if (Object.is(prevObj, nextObj)) {\n    return false;\n  }\n  if (!isObject(prevObj) || !isObject(nextObj)) return true;\n  const used = (affected as Affected).get(getOriginalObject(prevObj));\n  if (!used) return true;\n  if (cache) {\n    const hit = (cache as ChangedCache).get(prevObj);\n    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n      return hit[CHANGED_PROPERTY];\n    }\n    // for object with cycles\n    (cache as ChangedCache).set(prevObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: false,\n    });\n  }\n  let changed: boolean | null = null;\n  try {\n    for (const key of used[HAS_KEY_PROPERTY] || []) {\n      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n      if (changed) return changed;\n    }\n    if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n      changed = isAllOwnKeysChanged(prevObj, nextObj);\n      if (changed) return changed;\n    } else {\n      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n        changed = hasPrev !== hasNext;\n        if (changed) return changed;\n      }\n    }\n    for (const key of used[KEYS_PROPERTY] || []) {\n      changed = isChanged(\n        (prevObj as any)[key],\n        (nextObj as any)[key],\n        affected,\n        cache,\n      );\n      if (changed) return changed;\n    }\n    if (changed === null) changed = true;\n    return changed;\n  } finally {\n    if (cache) {\n      cache.set(prevObj, {\n        [NEXT_OBJECT_PROPERTY]: nextObj,\n        [CHANGED_PROPERTY]: changed,\n      });\n    }\n  }\n};\n\n// explicitly track object with memo\nexport const trackMemo = (obj: unknown) => {\n  if (isObjectToTrack(obj)) {\n    return TRACK_MEMO_SYMBOL in obj;\n  }\n  return false;\n};\n\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = <T>(obj: T): T | null => {\n  if (isObjectToTrack(obj)) {\n    return (obj as { [GET_ORIGINAL_SYMBOL]?: T })[GET_ORIGINAL_SYMBOL] || null;\n  }\n  return null;\n};\n\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj: object, mark = true) => {\n  objectsToTrack.set(obj, mark);\n};\n\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (\n  obj: unknown,\n  affected: WeakMap<object, unknown>,\n  onlyWithValues?: boolean,\n) => {\n  const list: (string | symbol)[][] = [];\n  const seen = new WeakSet();\n  const walk = (x: unknown, path?: (string | symbol)[]) => {\n    if (seen.has(x as object)) {\n      // for object with cycles\n      return;\n    }\n    if (isObject(x)) {\n      seen.add(x);\n    }\n    const used = isObject(x) && (affected as Affected).get(getOriginalObject(x));\n    if (used) {\n      used[HAS_KEY_PROPERTY]?.forEach((key) => {\n        const segment = `:has(${String(key)})`;\n        list.push(path ? [...path, segment] : [segment]);\n      });\n      if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n        const segment = ':ownKeys';\n        list.push(path ? [...path, segment] : [segment]);\n      } else {\n        used[HAS_OWN_KEY_PROPERTY]?.forEach((key) => {\n          const segment = `:hasOwn(${String(key)})`;\n          list.push(path ? [...path, segment] : [segment]);\n        });\n      }\n      used[KEYS_PROPERTY]?.forEach((key) => {\n        if (!onlyWithValues || 'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n          walk((x as any)[key], path ? [...path, key] : [key]);\n        }\n      });\n    } else if (path) {\n      list.push(path);\n    }\n  };\n  walk(obj);\n  return list;\n};\n\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn: typeof newProxy) => {\n  newProxy = fn;\n};\n","// Credits: https://github.com/pmndrs/valtio\n\nimport { getUntracked, markToTrack } from \"proxy-compare\"\n\nconst isDev = process.env.NODE_ENV !== \"production\"\nconst isObject = (x: unknown): x is object => typeof x === \"object\" && x !== null\n\ntype AsRef = { $$valtioRef: true }\n\ntype ProxyObject = object\n\ntype Path = (string | symbol)[]\ntype Op =\n  | [op: \"set\", path: Path, value: unknown, prevValue: unknown]\n  | [op: \"delete\", path: Path, prevValue: unknown]\n  | [op: \"resolve\", path: Path, value: unknown]\n  | [op: \"reject\", path: Path, error: unknown]\ntype Listener = (op: Op, nextVersion: number) => void\n\ntype AnyFunction = (...args: any[]) => any\n\nexport type Snapshot<T> = T extends AnyFunction\n  ? T\n  : T extends AsRef\n  ? T\n  : T extends Promise<any>\n  ? Awaited<T>\n  : {\n      readonly [K in keyof T]: Snapshot<T[K]>\n    }\n\ntype HandlePromise = <P extends Promise<any>>(promise: P) => Awaited<P>\n\ntype CreateSnapshot = <T extends object>(target: T, version: number, handlePromise?: HandlePromise) => T\n\ntype RemoveListener = () => void\ntype AddListener = (listener: Listener) => RemoveListener\n\ntype ProxyState = readonly [\n  target: object,\n  ensureVersion: (nextCheckVersion?: number) => number,\n  createSnapshot: CreateSnapshot,\n  addListener: AddListener,\n]\n\n// shared state\nconst proxyStateMap = new WeakMap<ProxyObject, ProxyState>()\nconst refSet = new WeakSet()\n\nconst buildProxyFunction = (\n  objectIs = Object.is,\n\n  newProxy = <T extends object>(target: T, handler: ProxyHandler<T>): T => new Proxy(target, handler),\n\n  canProxy = (x: unknown) =>\n    isObject(x) &&\n    !refSet.has(x) &&\n    (Array.isArray(x) || !(Symbol.iterator in x)) &&\n    !(x instanceof WeakMap) &&\n    !(x instanceof WeakSet) &&\n    !(x instanceof Error) &&\n    !(x instanceof Number) &&\n    !(x instanceof Date) &&\n    !(x instanceof String) &&\n    !(x instanceof RegExp) &&\n    !(x instanceof ArrayBuffer),\n\n  defaultHandlePromise = <P extends Promise<any>>(\n    promise: P & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\"\n      value?: Awaited<P>\n      reason?: unknown\n    },\n  ) => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value as Awaited<P>\n      case \"rejected\":\n        throw promise.reason\n      default:\n        throw promise\n    }\n  },\n\n  snapCache = new WeakMap<object, [version: number, snap: unknown]>(),\n\n  createSnapshot: CreateSnapshot = <T extends object>(\n    target: T,\n    version: number,\n    handlePromise: HandlePromise = defaultHandlePromise,\n  ): T => {\n    const cache = snapCache.get(target)\n    if (cache?.[0] === version) {\n      return cache[1] as T\n    }\n    const snap: any = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target))\n    markToTrack(snap, true) // mark to track\n    snapCache.set(target, [version, snap])\n    Reflect.ownKeys(target).forEach((key) => {\n      const value = Reflect.get(target, key)\n      if (refSet.has(value as object)) {\n        markToTrack(value as object, false) // mark not to track\n        snap[key] = value\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value)\n          },\n        })\n      } else if (proxyStateMap.has(value as object)) {\n        snap[key] = snapshot(value as object, handlePromise)\n      } else {\n        snap[key] = value\n      }\n    })\n    return Object.freeze(snap)\n  },\n\n  proxyCache = new WeakMap<object, ProxyObject>(),\n\n  versionHolder = [1, 1] as [number, number],\n\n  proxyFunction = <T extends object>(initialObject: T): T => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\")\n    }\n    const found = proxyCache.get(initialObject) as T | undefined\n    if (found) {\n      return found\n    }\n    let version = versionHolder[0]\n    const listeners = new Set<Listener>()\n    const notifyUpdate = (op: Op, nextVersion = ++versionHolder[0]) => {\n      if (version !== nextVersion) {\n        version = nextVersion\n        listeners.forEach((listener) => listener(op, nextVersion))\n      }\n    }\n    let checkVersion = versionHolder[1]\n    const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion\n        propProxyStates.forEach(([propProxyState]) => {\n          const propVersion = propProxyState[1](nextCheckVersion)\n          if (propVersion > version) {\n            version = propVersion\n          }\n        })\n      }\n      return version\n    }\n    const createPropListener =\n      (prop: string | symbol): Listener =>\n      (op, nextVersion) => {\n        const newOp: Op = [...op]\n        newOp[1] = [prop, ...(newOp[1] as Path)]\n        notifyUpdate(newOp, nextVersion)\n      }\n    const propProxyStates = new Map<string | symbol, readonly [ProxyState, RemoveListener?]>()\n    const addPropListener = (prop: string | symbol, propProxyState: ProxyState) => {\n      if (isDev && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\")\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop))\n        propProxyStates.set(prop, [propProxyState, remove])\n      } else {\n        propProxyStates.set(prop, [propProxyState])\n      }\n    }\n    const removePropListener = (prop: string | symbol) => {\n      const entry = propProxyStates.get(prop)\n      if (entry) {\n        propProxyStates.delete(prop)\n        entry[1]?.()\n      }\n    }\n    const addListener = (listener: Listener) => {\n      listeners.add(listener)\n      if (listeners.size === 1) {\n        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n          if (isDev && prevRemove) {\n            throw new Error(\"remove already exists\")\n          }\n          const remove = propProxyState[3](createPropListener(prop))\n          propProxyStates.set(prop, [propProxyState, remove])\n        })\n      }\n      const removeListener = () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          propProxyStates.forEach(([propProxyState, remove], prop) => {\n            if (remove) {\n              remove()\n              propProxyStates.set(prop, [propProxyState])\n            }\n          })\n        }\n      }\n      return removeListener\n    }\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject))\n    const handler: ProxyHandler<T> = {\n      deleteProperty(target: T, prop: string | symbol) {\n        const prevValue = Reflect.get(target, prop)\n        removePropListener(prop)\n        const deleted = Reflect.deleteProperty(target, prop)\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue])\n        }\n        return deleted\n      },\n      set(target: T, prop: string | symbol, value: any, receiver: object) {\n        const hasPrevValue = Reflect.has(target, prop)\n        const prevValue = Reflect.get(target, prop, receiver)\n        if (\n          hasPrevValue &&\n          (objectIs(prevValue, value) || (proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value))))\n        ) {\n          return true\n        }\n        removePropListener(prop)\n        if (isObject(value)) {\n          value = getUntracked(value) || value\n        }\n        let nextValue = value\n        if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n          // do nothing\n        } else if (value instanceof Promise) {\n          value\n            .then((v) => {\n              value.status = \"fulfilled\"\n              value.value = v\n              notifyUpdate([\"resolve\", [prop], v])\n            })\n            .catch((e) => {\n              value.status = \"rejected\"\n              value.reason = e\n              notifyUpdate([\"reject\", [prop], e])\n            })\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value)\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue)\n          if (childProxyState) {\n            addPropListener(prop, childProxyState)\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver)\n        notifyUpdate([\"set\", [prop], value, prevValue])\n        return true\n      },\n    }\n    const proxyObject = newProxy(baseObject, handler)\n    proxyCache.set(initialObject, proxyObject)\n    const proxyState: ProxyState = [baseObject, ensureVersion, createSnapshot, addListener]\n    proxyStateMap.set(proxyObject, proxyState)\n    Reflect.ownKeys(initialObject).forEach((key) => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key) as PropertyDescriptor\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc)\n      } else {\n        proxyObject[key as keyof T] = initialObject[key as keyof T]\n      }\n    })\n    return proxyObject\n  },\n) =>\n  [\n    // public functions\n    proxyFunction,\n    // shared state\n    proxyStateMap,\n    refSet,\n    // internal things\n    objectIs,\n    newProxy,\n    canProxy,\n    defaultHandlePromise,\n    snapCache,\n    createSnapshot,\n    proxyCache,\n    versionHolder,\n  ] as const\n\nconst [proxyFunction] = buildProxyFunction()\n\nexport function proxy<T extends object>(initialObject: T = {} as T): T {\n  return proxyFunction(initialObject)\n}\n\nexport function getVersion(proxyObject: unknown): number | undefined {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  return proxyState?.[1]()\n}\n\nexport function subscribe<T extends object>(\n  proxyObject: T,\n  callback: (ops: Op[]) => void,\n  notifyInSync?: boolean,\n): () => void {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  let promise: Promise<void> | undefined\n  const ops: Op[] = []\n  const addListener = (proxyState as ProxyState)[3]\n  let isListenerActive = false\n  const listener: Listener = (op) => {\n    ops.push(op)\n    if (notifyInSync) {\n      callback(ops.splice(0))\n      return\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = undefined\n        if (isListenerActive) {\n          callback(ops.splice(0))\n        }\n      })\n    }\n  }\n  const removeListener = addListener(listener)\n  isListenerActive = true\n  return () => {\n    isListenerActive = false\n    removeListener()\n  }\n}\n\nexport function snapshot<T extends object>(proxyObject: T, handlePromise?: HandlePromise): Snapshot<T> {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState as ProxyState\n  return createSnapshot(target, ensureVersion(), handlePromise) as Snapshot<T>\n}\n\nexport function ref<T extends object>(obj: T): T & AsRef {\n  refSet.add(obj)\n  return obj as T & AsRef\n}\n","import { proxy, snapshot, type Snapshot } from \"./proxy\"\n\nexport function proxyWithComputed<T extends object, U extends object>(\n  initialObject: T,\n  computedFns: {\n    [K in keyof U]:\n      | ((snap: Snapshot<T>) => U[K])\n      | {\n          get: (snap: Snapshot<T>) => U[K]\n          set?: (state: T, newValue: U[K]) => void\n        }\n  },\n) {\n  const keys = Object.keys(computedFns) as (keyof U)[]\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\")\n    }\n    const computedFn = computedFns[key]\n    const { get, set } = (typeof computedFn === \"function\" ? { get: computedFn } : computedFn) as {\n      get: (snap: Snapshot<T>) => U[typeof key]\n      set?: (state: T, newValue: U[typeof key]) => void\n    }\n    const desc: PropertyDescriptor = {}\n    desc.get = () => get(snapshot(proxyObject))\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue)\n    }\n    Object.defineProperty(initialObject, key, desc)\n  })\n  const proxyObject = proxy(initialObject) as T & U\n  return proxyObject\n}\n","import { snapshot, subscribe } from \"./proxy\"\n\nexport type CompareFn<T = any> = (prev: T, next: T) => boolean\n\nconst defaultCompareFn: CompareFn = (prev, next) => Object.is(prev, next)\n\nexport function subscribeKey<T extends object, K extends keyof T>(\n  obj: T,\n  key: K,\n  fn: (value: T[K]) => void,\n  sync?: boolean,\n  compareFn?: (prev: T[K], next: T[K]) => boolean,\n) {\n  let prev: any = Reflect.get(snapshot(obj), key)\n  const isEqual = compareFn || defaultCompareFn\n  function onSnapshotChange() {\n    const snap = snapshot(obj) as T\n    if (isEqual(prev, snap[key])) return\n    fn(snap[key])\n    prev = Reflect.get(snap, key)\n  }\n  return subscribe(obj, onSnapshotChange, sync)\n}\n","function set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nexport function klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n","export { proxy, ref, snapshot, subscribe } from \"@zag-js/store\"\nexport { deepMerge } from \"./deep-merge\"\nexport { choose, guards } from \"./guard-utils\"\nexport * from \"./machine\"\nexport { mergeProps } from \"./merge-props\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"./type-utils\"\nexport type { StateMachine } from \"./types\"\n","export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => removeAt(v, v.indexOf(item))\n\nexport const removeAt = <T>(v: T[], i: number): T[] => {\n  if (i > -1) v.splice(i, 1)\n  return v\n}\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n","export const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n","export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n","export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n","export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n","import { compact, isObject } from \"@zag-js/utils\"\n\nexport function deepMerge<T extends Record<string, any>>(source: T, ...objects: T[]): T {\n  for (const obj of objects) {\n    const target = compact(obj)\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {} as any\n        }\n        deepMerge(source[key], obj[key])\n      } else {\n        source[key] = obj[key]\n      }\n    }\n  }\n  return source\n}\n","import { isArray, isObject, isString } from \"@zag-js/utils\"\nimport { klona } from \"klona/full\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\nexport function structuredClone<T>(v: T): T {\n  return klona(v)\n}\n\nexport function toEvent<T extends S.EventObject>(event: S.Event<T>): T {\n  const obj = isString(event) ? { type: event } : event\n  return obj as T\n}\n\nexport function toArray<T>(value: T | T[] | undefined): T[] {\n  if (!value) return []\n  return isArray(value) ? value.slice() : [value]\n}\n\nexport function isGuardHelper(value: any): value is { predicate: (guards: Dict) => any } {\n  return isObject(value) && value.predicate != null\n}\n","import { isFunction, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { isGuardHelper } from \"./utils\"\n\nconst Truthy = () => true\n\n/* -----------------------------------------------------------------------------\n * The following functions are used to determine a guard's truthiness\n * -----------------------------------------------------------------------------*/\n\nfunction exec<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guardMap: Dict,\n  ctx: TContext,\n  event: TEvent,\n  meta: S.GuardMeta<TContext, TState, TEvent>,\n) {\n  return (guard: S.Guard<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta)\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta)\n    }\n    return guard.predicate(guardMap)(ctx, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Guard helpers (for combining guards)\n * -----------------------------------------------------------------------------*/\n\nfunction or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean),\n  }\n}\n\nfunction and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean),\n  }\n}\n\nfunction not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  condition: S.Guard<TContext, TState, TEvent>,\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n      return !exec(guardMap, ctx, event, meta)(condition)\n    },\n  }\n}\n\nfunction stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...values: TState[\"value\"][]\n): S.GuardExpression<TContext, TState, TEvent> {\n  return (_ctx, _evt, meta) => meta.state.matches(...values)\n}\n\nexport const guards = { or, and, not, stateIn }\n\n/* -----------------------------------------------------------------------------\n * Action guard helper. Used to determie the action to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function choose<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  actions: Array<{ guard?: S.Guard<TContext, TState, TEvent>; actions: S.PureActions<TContext, TState, TEvent> }>,\n): S.ChooseHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      actions.find((def) => {\n        const guard = def.guard ?? Truthy\n        return exec(guardMap, ctx, event, meta)(guard)\n      })?.actions,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the guard to be used\n * -----------------------------------------------------------------------------*/\n\nexport function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guard: S.Guard<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  guard = guard ?? Truthy\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      const value = guardMap[guard]\n      return isFunction(value) ? value(context, event, meta) : value\n    }\n\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta)\n    }\n\n    return guard?.(context, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the actions to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  values: S.Actions<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta)\n    }\n    return values\n  }\n}\n","import { ref, snapshot, subscribe, subscribeKey } from \"@zag-js/store\"\nimport {\n  cast,\n  clear,\n  compact,\n  invariant,\n  isArray,\n  isDev,\n  isObject,\n  isString,\n  noop,\n  runIfFn,\n  uuid,\n  warn,\n} from \"@zag-js/utils\"\nimport { createProxy } from \"./create-proxy\"\nimport { deepMerge } from \"./deep-merge\"\nimport { determineDelayFn } from \"./delay-utils\"\nimport { determineActionsFn, determineGuardFn } from \"./guard-utils\"\nimport { determineTransitionFn } from \"./transition-utils\"\nimport {\n  ActionTypes,\n  MachineStatus,\n  MachineType,\n  type Dict,\n  type StateMachine as S,\n  type VoidFunction,\n  type Writable,\n} from \"./types\"\nimport { structuredClone, toArray, toEvent } from \"./utils\"\n\nexport class Machine<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> {\n  public status: MachineStatus = MachineStatus.NotStarted\n  public readonly state: S.State<TContext, TState, TEvent>\n\n  public initialState: S.StateInfo<TContext, TState, TEvent> | undefined\n  public initialContext: TContext\n\n  public id: string\n\n  public type: MachineType = MachineType.Machine\n\n  // Cleanup function map (per state)\n  private activityEvents = new Map<string, Map<string, VoidFunction>>()\n  private delayedEvents = new Map<string, VoidFunction[]>()\n\n  // state update listeners the user can opt-in for\n  private stateListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextListeners = new Set<S.ContextListener<TContext>>()\n  private eventListeners = new Set<S.EventListener<TEvent>>()\n  private doneListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextWatchers = new Set<VoidFunction>()\n\n  // Cleanup functions (for `subscribe`)\n  private removeStateListener: VoidFunction = noop\n  private removeEventListener: VoidFunction = noop\n  private removeContextListener: VoidFunction = noop\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: AnyMachine\n  private children = new Map<string, AnyMachine>()\n\n  // A map of guard, action, delay implementations\n  private guardMap: S.GuardMap<TContext, TState, TEvent>\n  private actionMap: S.ActionMap<TContext, TState, TEvent>\n  private delayMap: S.DelayMap<TContext, TEvent>\n  private activityMap: S.ActivityMap<TContext, TState, TEvent>\n  private sync: boolean\n  public options: S.MachineOptions<TContext, TState, TEvent>\n  public config: S.MachineConfig<TContext, TState, TEvent>\n\n  // Let's get started!\n  constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>) {\n    // clone the config and options\n    this.config = structuredClone(config)\n    this.options = structuredClone(options ?? {})\n\n    this.id = this.config.id ?? `machine-${uuid()}`\n\n    // maps\n    this.guardMap = this.options?.guards ?? {}\n    this.actionMap = this.options?.actions ?? {}\n    this.delayMap = this.options?.delays ?? {}\n    this.activityMap = this.options?.activities ?? {}\n    this.sync = this.options?.sync ?? false\n\n    // create mutatable state\n    this.state = createProxy(this.config)\n    this.initialContext = snapshot(this.state.context)\n    this.transformContext(this.state.context)\n\n    // created actions\n    const event = toEvent<TEvent>(ActionTypes.Created)\n    this.executeActions(this.config?.created, event)\n  }\n\n  // immutable state value\n  private get stateSnapshot(): S.State<TContext, TState, TEvent> {\n    return cast(snapshot(this.state))\n  }\n\n  public getState(): S.State<TContext, TState, TEvent> {\n    return this.stateSnapshot\n  }\n\n  // immutable context value\n  private get contextSnapshot(): TContext {\n    return this.stateSnapshot.context\n  }\n\n  // Starts the interpreted machine.\n  public start = (init?: S.StateInit<TContext, TState>) => {\n    // reset state back to empty (for SSR, we had to set state.value to initial value)\n    this.state.value = \"\"\n\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) {\n      return this\n    }\n\n    this.status = MachineStatus.Running\n\n    // subscribe to state changes\n    this.removeStateListener = subscribe(\n      this.state,\n      () => {\n        this.stateListeners.forEach((listener) => {\n          listener(this.stateSnapshot)\n        })\n      },\n      this.sync,\n    )\n\n    // subscribe to event changes\n    this.removeEventListener = subscribeKey(\n      this.state,\n      \"event\",\n      (event) => {\n        this.executeActions(this.config.onEvent, event)\n        this.eventListeners.forEach((listener) => {\n          listener(event)\n        })\n      },\n      this.sync,\n    )\n\n    // subscribe to context changes\n    this.removeContextListener = subscribe(\n      this.state.context,\n      () => {\n        this.log(\"Context:\", this.contextSnapshot)\n        this.contextListeners.forEach((listener) => {\n          listener(this.contextSnapshot)\n        })\n      },\n      this.sync || this.options.debug,\n    )\n\n    this.setupContextWatchers()\n\n    // execute initial actions and activities\n    this.executeActivities(toEvent<TEvent>(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start)\n    this.executeActions(this.config.entry, toEvent<TEvent>(ActionTypes.Start))\n\n    // start transition\n    const event = toEvent<TEvent>(ActionTypes.Init)\n\n    const target = isObject(init) ? init.value : init\n    const context = isObject(init) ? init.context : undefined\n\n    if (context) {\n      this.setContext(context as Partial<TContext>)\n    }\n\n    // start transition definition\n    const transition = {\n      target: target ?? this.config.initial,\n    }\n\n    const next = this.getNextStateInfo(transition, event)\n    this.initialState = next\n\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return this\n  }\n\n  private setupContextWatchers = () => {\n    for (const [key, fn] of Object.entries(this.config.watch ?? {})) {\n      const compareFn = this.options.compareFns?.[key]\n      const cleanup = subscribeKey(\n        this.state.context,\n        key,\n        () => {\n          this.executeActions(fn, this.state.event as TEvent)\n        },\n        this.sync,\n        compareFn,\n      )\n      this.contextWatchers.add(cleanup)\n    }\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    // exit current state\n    this.performExitEffects(this.state.value!, toEvent<TEvent>(ActionTypes.Stop))\n\n    // execute root stop or exit actions\n    this.executeActions(this.config.exit, toEvent<TEvent>(ActionTypes.Stop))\n\n    this.setState(\"\")\n    this.setEvent(ActionTypes.Stop)\n\n    // cleanups\n    this.stopStateListeners()\n    this.stopChildren()\n    this.stopActivities()\n    this.stopDelayedEvents()\n    this.stopContextWatchers()\n    this.stopEventListeners()\n    this.stopContextListeners()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopEventListeners = () => {\n    this.eventListeners.clear()\n    this.removeEventListener()\n  }\n\n  private stopContextListeners = () => {\n    this.contextListeners.clear()\n    this.removeContextListener()\n  }\n\n  private stopStateListeners = () => {\n    this.removeStateListener()\n    this.stateListeners.clear()\n  }\n\n  private stopContextWatchers = () => {\n    this.contextWatchers.forEach((fn) => fn())\n    this.contextWatchers.clear()\n  }\n\n  private stopDelayedEvents = () => {\n    this.delayedEvents.forEach((state) => {\n      state.forEach((stop) => stop())\n    })\n    this.delayedEvents.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (state?: TState[\"value\"]) => {\n    // stop activities for a state\n    if (state) {\n      this.activityEvents.get(state)?.forEach((stop) => stop())\n      this.activityEvents.get(state)?.clear()\n      this.activityEvents.delete(state)\n    } else {\n      // stop every running activity\n      this.activityEvents.forEach((state) => {\n        state.forEach((stop) => stop())\n        state.clear()\n      })\n      this.activityEvents.clear()\n    }\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  public sendChild = (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = runIfFn(to, this.contextSnapshot)\n    const child = this.children.get(id)\n    if (!child) {\n      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`)\n    }\n    child!.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  public stopChild = (id: string) => {\n    if (!this.children.has(id)) {\n      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`)\n    }\n    this.children.get(id)!.stop()\n    this.children.delete(id)\n  }\n\n  public removeChild = (id: string) => {\n    this.children.delete(id)\n  }\n\n  // Stop and delete spawned actors\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  public spawn = <TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(\n    src: MachineSrc<TContext, TState, TEvent>,\n    id?: string,\n  ) => {\n    const actor = runIfFn(src)\n    if (id) actor.id = id\n    actor.type = MachineType.Actor\n    actor.setParent(this)\n    this.children.set(actor.id, cast(actor))\n\n    actor\n      .onDone(() => {\n        this.removeChild(actor.id)\n      })\n      .start()\n\n    return cast<typeof actor>(ref(actor))\n  }\n\n  private stopActivity = (key: string) => {\n    if (!this.state.value) return\n    const cleanups = this.activityEvents.get(this.state.value)\n    cleanups?.get(key)?.() // cleanup\n    cleanups?.delete(key) // remove from map\n  }\n\n  private addActivityCleanup = (state: TState[\"value\"] | null, key: string, cleanup: VoidFunction) => {\n    if (!state) return\n    if (!this.activityEvents.has(state)) {\n      this.activityEvents.set(state, new Map([[key, cleanup]]))\n    } else {\n      this.activityEvents.get(state)?.set(key, cleanup)\n    }\n  }\n\n  private setState = (target: TState[\"value\"] | null) => {\n    this.state.previousValue = this.state.value\n    this.state.value = target\n\n    const stateNode = this.getStateNode(target)\n\n    if (target == null) {\n      // remove all tags\n      clear(this.state.tags)\n    } else {\n      this.state.tags = toArray(stateNode?.tags)\n    }\n  }\n\n  private transformContext = (context: Partial<Writable<TContext>> | Partial<TContext>) => {\n    this.options?.transformContext?.(context)\n    return context as TContext\n  }\n\n  /**\n   * To used within side effects for React or Vue to update context\n   */\n  public setContext = (context: Partial<Writable<TContext>> | undefined) => {\n    if (!context) return\n    deepMerge(this.state.context, this.transformContext(context))\n  }\n\n  public withContext = (context: Partial<Writable<TContext>>) => {\n    const transformed = this.transformContext(context)\n    const newContext = { ...this.config.context, ...compact(transformed) } as TContext\n    return new Machine({ ...this.config, context: newContext }, this.options)\n  }\n\n  public setOptions = (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => {\n    const opts = compact(options)\n    this.actionMap = { ...this.actionMap, ...opts.actions }\n    this.delayMap = { ...this.delayMap, ...opts.delays }\n    this.activityMap = { ...this.activityMap, ...opts.activities }\n    this.guardMap = { ...this.guardMap, ...opts.guards }\n  }\n\n  private getStateNode = (state: TState[\"value\"] | null) => {\n    if (!state) return\n    return this.config.states?.[state]\n  }\n\n  private getNextStateInfo = (\n    transitions: S.Transitions<TContext, TState, TEvent>,\n    event: TEvent,\n  ): S.StateInfo<TContext, TState, TEvent> => {\n    // pick transition\n    const transition = this.determineTransition(transitions, event)\n\n    const isTargetless = !transition?.target\n    const target = transition?.target ?? this.state.value\n    const changed = this.state.value !== target\n\n    const stateNode = this.getStateNode(target)\n    const reenter = !isTargetless && !changed && !transition?.internal\n\n    const info = {\n      reenter,\n      transition,\n      stateNode,\n      target: target!,\n      changed,\n    }\n\n    this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target)\n\n    return info\n  }\n\n  private getActionFromDelayedTransition = (transition: S.DelayedTransition<TContext, TState, TEvent>) => {\n    // get the computed delay\n    const event = toEvent<TEvent>(ActionTypes.After)\n\n    const determineDelay = determineDelayFn(transition.delay, this.delayMap)\n    const delay = determineDelay(this.contextSnapshot, event)\n\n    let id: ReturnType<typeof globalThis.setTimeout>\n\n    return {\n      entry: () => {\n        id = globalThis.setTimeout(() => {\n          const next = this.getNextStateInfo(transition, event)\n          this.performStateChangeEffects(this.state.value!, next, event)\n        }, delay)\n      },\n      exit: () => {\n        globalThis.clearTimeout(id)\n      },\n    }\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the `after` defintion into `entry` and `exit`\n   *  functions and append them to the state's `entry` and `exit` actions\n   */\n  private getDelayedEventActions = (state: TState[\"value\"]) => {\n    const stateNode = this.getStateNode(state)\n    const event = toEvent<TEvent>(ActionTypes.After)\n\n    if (!stateNode || !stateNode.after) return\n\n    const entries: VoidFunction[] = []\n    const exits: VoidFunction[] = []\n\n    if (isArray(stateNode.after)) {\n      //\n      const transition = this.determineTransition(stateNode.after, event)\n      if (!transition) return\n\n      const actions = this.getActionFromDelayedTransition(transition)\n      entries.push(actions.entry)\n      exits.push(actions.exit)\n      //\n    } else if (isObject(stateNode.after)) {\n      //\n      for (const delay in stateNode.after) {\n        const transition = stateNode.after[delay]\n        let resolvedTransition: S.DelayedTransition<TContext, TState, TEvent> = {}\n\n        if (isArray(transition)) {\n          //\n          const picked = this.determineTransition(transition, event)\n          if (picked) resolvedTransition = picked\n          //\n        } else if (isString(transition)) {\n          resolvedTransition = { target: transition, delay }\n        } else {\n          resolvedTransition = { ...transition, delay }\n        }\n\n        const actions = this.getActionFromDelayedTransition(resolvedTransition)\n\n        entries.push(actions.entry)\n        exits.push(actions.exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  private get self(): S.Self<TContext, TState, TEvent> {\n    const self = this\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this) as any,\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot\n      },\n      get initialContext() {\n        return self.initialContext\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\"\n      },\n    }\n  }\n\n  private get meta(): S.Meta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key],\n    }\n  }\n\n  private get guardMeta(): S.GuardMeta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n    }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actions`) or actual functions.\n   */\n  private executeActions = (actions: S.Actions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    for (const action of toArray(pickedActions)) {\n      const fn = isString(action) ? this.actionMap?.[action] : action\n      warn(\n        isString(action) && !fn,\n        `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``,\n      )\n      fn?.(this.state.context, event, this.meta)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: Array<S.Activity<TContext, TState, TEvent>>,\n    state?: TState[\"value\"],\n  ) => {\n    for (const activity of activities) {\n      const fn = isString(activity) ? this.activityMap?.[activity] : activity\n\n      if (!fn) {\n        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``)\n        continue\n      }\n\n      const cleanup = fn(this.state.context, event, this.meta)\n\n      if (cleanup) {\n        const key = isString(activity) ? activity : activity.name || uuid()\n        this.addActivityCleanup(state ?? this.state.value, key, cleanup)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to transition. `every` can be:\n   * - An array of possible actions to run (we need to pick the first match based on guard)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"] | undefined,\n    callbackfn: (activity: S.Activity<TContext, TState, TEvent>) => void,\n  ) => {\n    if (!every) return\n    const event = toEvent<TEvent>(ActionTypes.Every)\n\n    // every: [{ interval: 2000, actions: [...], guard: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], guard: ... }\n      const picked = toArray(every).find((transition) => {\n        //\n        const delayOrFn = transition.delay\n        const determineDelay = determineDelayFn(delayOrFn, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, event)\n\n        const determineGuard = determineGuardFn(transition.guard, this.guardMap)\n        const guard = determineGuard(this.contextSnapshot, event, this.guardMeta)\n\n        return guard ?? delay != null\n      })\n\n      if (!picked) return\n\n      const determineDelay = determineDelayFn(picked.delay, this.delayMap)\n      const delay = determineDelay(this.contextSnapshot, event)\n\n      const activity = () => {\n        const id = globalThis.setInterval(() => {\n          this.executeActions(picked.actions, event)\n        }, delay)\n        return () => {\n          globalThis.clearInterval(id)\n        }\n      }\n      callbackfn(activity)\n      //\n    } else {\n      // every = { 1000: [fn, fn] }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const determineDelay = determineDelayFn(interval, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, event)\n\n        // create the activity to run for each `every` reaction\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(actions, event)\n          }, delay)\n          return () => {\n            globalThis.clearInterval(id)\n          }\n        }\n        callbackfn(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent | TEvent[\"type\"]) => {\n    this.state.previousEvent = this.state.event\n    this.state.event = ref(toEvent(event))\n  }\n\n  private performExitEffects = (current: TState[\"value\"] | undefined, event: TEvent) => {\n    const currentState = this.state.value!\n\n    // don't clean up root state, it'll get cleaned up on stop()\n    if (currentState === \"\") return\n\n    const stateNode = current ? this.getStateNode(current) : undefined\n\n    // cleanup activities for current state\n    this.stopActivities(currentState)\n\n    // get explicit exit and implicit \"after.exit\" actions for current state\n    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    const exitActions = toArray(_exit)\n\n    const afterExitActions = this.delayedEvents.get(currentState)\n\n    if (afterExitActions) {\n      exitActions.push(...afterExitActions)\n    }\n\n    // call all exit actions for current state\n    this.executeActions(exitActions, event)\n\n    // remove all registered listeners\n    this.eventListeners.clear()\n  }\n\n  private performEntryEffects = (next: TState[\"value\"], event: TEvent) => {\n    const stateNode = this.getStateNode(next)\n\n    // execute activities for next state\n    const activities = toArray(stateNode?.activities)\n\n    // if `every` is defined, create an activity and append to activities\n    this.createEveryActivities(stateNode?.every, (activity) => {\n      activities.unshift(activity)\n    })\n\n    if (activities.length > 0) {\n      this.executeActivities(event, activities)\n    }\n\n    // get all entry actions\n    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n      this.contextSnapshot,\n      event,\n      this.guardMeta,\n    )\n    const entryActions = toArray(pickedActions)\n    const afterActions = this.getDelayedEventActions(next)\n\n    if (stateNode?.after && afterActions) {\n      this.delayedEvents.set(next, afterActions?.exits)\n      entryActions.push(...afterActions.entries)\n    }\n\n    // execute entry actions for next state\n    this.executeActions(entryActions, event)\n\n    if (stateNode?.type === \"final\") {\n      this.state.done = true\n      this.doneListeners.forEach((listener) => {\n        listener(this.stateSnapshot)\n      })\n      this.stop()\n    }\n  }\n\n  private performTransitionEffects = (\n    transitions: S.Transitions<TContext, TState, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    // execute transition actions\n    const transition = this.determineTransition(transitions, event)\n    this.executeActions(transition?.actions, event)\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performStateChangeEffects = (\n    current: TState[\"value\"] | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    // update event\n    this.setEvent(event)\n\n    const changed = next.changed || next.reenter\n\n    if (changed) {\n      this.performExitEffects(current, event)\n    }\n\n    // execute transition actions\n    this.performTransitionEffects(next.transition, event)\n\n    // go to next state\n    this.setState(next.target)\n\n    if (changed) {\n      this.performEntryEffects(next.target, event)\n    }\n  }\n\n  private determineTransition = (transition: S.Transitions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const fn = determineTransitionFn(transition, this.guardMap)\n    return fn?.(this.contextSnapshot, event, this.guardMeta)\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  public sendParent = (evt: S.Event<S.AnyEventObject>) => {\n    if (!this.parent) {\n      invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\")\n    }\n    const event = toEvent<S.AnyEventObject>(evt)\n    this.parent?.send(event)\n  }\n\n  private log = (...args: any[]) => {\n    if (isDev() && this.options.debug) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  public send = (evt: S.Event<TEvent>) => {\n    const event = toEvent<TEvent>(evt)\n    this.transition(this.state.value, event)\n  }\n\n  public transition = (state: TState[\"value\"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => {\n    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode\n\n    const event = toEvent(evt)\n\n    if (!stateNode && !this.config.on) {\n      const msg =\n        this.status === MachineStatus.Stopped\n          ? \"[@zag-js/core > transition] Cannot transition a stopped machine\"\n          : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`\n      warn(msg)\n      return\n    }\n\n    const transitions: S.Transitions<TContext, TState, TEvent> =\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const next = this.getNextStateInfo(transitions, event)\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return next.stateNode\n  }\n\n  subscribe = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n\n    return () => {\n      this.stateListeners.delete(listener)\n    }\n  }\n\n  public onDone = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.doneListeners.add(listener)\n    return this\n  }\n\n  public onTransition = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n    return this\n  }\n\n  public onChange = (listener: S.ContextListener<TContext>) => {\n    this.contextListeners.add(listener)\n    return this\n  }\n\n  public onEvent = (listener: S.EventListener<TEvent>) => {\n    this.eventListeners.add(listener)\n    return this\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Machine\"\n  }\n}\n\nexport type MachineSrc<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>)\n\nexport type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>\n\nexport const createMachine = <\n  TContext extends Dict,\n  TState extends S.StateSchema = S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n  options?: S.MachineOptions<TContext, TState, TEvent>,\n) => new Machine(config, options)\n","import { proxy, proxyWithComputed } from \"@zag-js/store\"\nimport { cast } from \"@zag-js/utils\"\nimport { ActionTypes, type Dict, type StateMachine as S } from \"./types\"\n\nexport function createProxy<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n) {\n  const computedContext: Dict = config.computed ?? cast<S.TComputedContext<TContext>>({})\n  const initialContext = config.context ?? cast<TContext>({})\n\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast<Dict>({}),\n    previousEvent: cast<Dict>({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: [] as Array<TState[\"tags\"]>,\n    hasTag(tag: TState[\"tags\"]): boolean {\n      return this.tags.includes(tag)\n    },\n    matches(...value: string[]): boolean {\n      return value.includes(this.value)\n    },\n    can(event: string): boolean {\n      return cast<any>(this).nextEvents.includes(event)\n    },\n    get nextEvents() {\n      const stateEvents = (config.states as Dict)?.[this.value]?.[\"on\"] ?? {}\n      const globalEvents = config?.on ?? {}\n      return Object.keys({ ...stateEvents, ...globalEvents })\n    },\n    get changed() {\n      if (this.event.value === ActionTypes.Init || !this.previousValue) return false\n      return this.value !== this.previousValue\n    },\n  })\n\n  return cast<S.State<TContext, TState, TEvent>>(state)\n}\n","import { invariant, isFunction, isNumber, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\n/**\n * Delay can be specified as:\n * - a string (reference to `options.delays`)\n * - a number (in ms)\n * - a function that returns a number (in ms)\n *\n * Let's resolve this to a number\n */\nexport function determineDelayFn<TContext extends Dict, TEvent extends S.EventObject>(\n  delay: S.Delay<TContext, TEvent> | undefined,\n  delaysMap: S.DelayMap<TContext, TEvent> | undefined,\n) {\n  return (context: TContext, event: TEvent) => {\n    if (isNumber(delay)) return delay\n\n    if (isFunction(delay)) {\n      return delay(context, event)\n    }\n\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay)\n\n      if (!Number.isNaN(value)) {\n        return value\n      }\n\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay]\n\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``,\n        )\n\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn\n      }\n    }\n  }\n}\n","import { isString } from \"@zag-js/utils\"\nimport { determineGuardFn } from \"./guard-utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { toArray } from \"./utils\"\n\n/**\n * A transition is an object that describes the next state, or/and actions\n * that should run when an event is sent.\n *\n * Transitions can be specified as:\n * - A single string: \"spinning\"\n * - An object with `target`, `actions`, or `guard`: { target: \"spinning\", actions: [...], guard: isValid }\n * - An array of possible transitions. In this case, we'll pick the first matching transition\n * depending on the `guard` specified\n */\n\nexport function toTarget<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  target: S.Transition<TContext, TState, TEvent>,\n): S.TransitionDefinition<TContext, TState, TEvent> {\n  return isString(target) ? { target } : target\n}\n\nexport function determineTransitionFn<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject,\n>(transitions: S.Transitions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    return toArray(transitions)\n      .map(toTarget)\n      .find((transition) => {\n        // get condition function\n        const determineGuard = determineGuardFn(transition.guard, guardMap)\n        const guard = determineGuard(context, event, meta)\n        return guard ?? transition.target ?? transition.actions\n      })\n  }\n}\n","import { callAll } from \"@zag-js/utils\"\n\ninterface Props {\n  [key: string]: any\n}\n\nconst clsx = (...args: (string | undefined)[]) =>\n  args\n    .map((str) => str?.trim())\n    .filter(Boolean)\n    .join(\" \")\n\ntype TupleTypes<T extends any[]> = T[number]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nconst eventRegex = /^on[A-Z]/\n\nexport function mergeProps<T extends Props>(...args: T[]): UnionToIntersection<TupleTypes<T[]>> {\n  let result: Props = {}\n\n  for (let props of args) {\n    for (let key in result) {\n      if (eventRegex.test(key) && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(result[key], props[key])\n        continue\n      }\n\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key])\n        continue\n      }\n\n      if (key === \"style\") {\n        result[key] = Object.assign({}, result[key] ?? {}, props[key] ?? {})\n        continue\n      }\n\n      result[key] = props[key] !== undefined ? props[key] : result[key]\n    }\n\n    // Add props from b that are not in a\n    for (let key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as any\n}\n","interface EventMap extends DocumentEventMap, WindowEventMap, HTMLElementEventMap {}\n\ntype Node = Document | HTMLElement | EventTarget | null\n\ntype Target = (() => Node) | Node\n\nexport const addDomEvent = <K extends keyof EventMap>(\n  target: Target,\n  eventName: K,\n  handler: (event: EventMap[K]) => void,\n  options?: boolean | AddEventListenerOptions,\n) => {\n  const node = typeof target === \"function\" ? target() : target\n  node?.addEventListener(eventName, handler as any, options)\n  return () => {\n    node?.removeEventListener(eventName, handler as any, options)\n  }\n}\n","export function isKeyboardClick(e: Pick<MouseEvent, \"detail\" | \"clientX\" | \"clientY\">) {\n  return e.detail === 0 || (e.clientX === 0 && e.clientY === 0)\n}\n\nexport function isPrintableKey(e: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">): boolean {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey\n}\n\nexport function isVirtualPointerEvent(e: PointerEvent) {\n  return (\n    (e.width === 0 && e.height === 0) ||\n    (e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\")\n  )\n}\n\nexport function isVirtualClick(e: MouseEvent | PointerEvent): boolean {\n  if ((e as any).mozInputSource === 0 && e.isTrusted) return true\n  return e.detail === 0 && !(e as PointerEvent).pointerType\n}\n\nexport const isLeftClick = (e: Pick<MouseEvent, \"button\">) => e.button === 0\n\nexport const isContextMenuEvent = (e: Pick<MouseEvent, \"button\" | \"ctrlKey\" | \"metaKey\">) => {\n  return e.button === 2 || (isMac() && e.ctrlKey && e.button === 0)\n}\n\nexport const isModifiedEvent = (e: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"altKey\">) =>\n  e.ctrlKey || e.altKey || e.metaKey\n\nconst isMac = () => /Mac|iPod|iPhone|iPad/.test(window.navigator.platform)\n","export function fireCustomEvent(el: HTMLElement | null, type: string, init?: CustomEventInit) {\n  if (!el) return\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.CustomEvent(type, init)\n  return el.dispatchEvent(event)\n}\n\nexport function fireBlurEvent(el: HTMLElement, init?: FocusEventInit) {\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.FocusEvent(\"blur\", init)\n  const allowed = el.dispatchEvent(event)\n  const bubbleInit = { ...init, bubbles: true }\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit))\n  return allowed\n}\n","import type { EventKeyOptions } from \"./types\"\n\nconst keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\",\n}\n\nconst rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\",\n}\n\n/**\n * Determine the event key based on text direction.\n */\nexport function getEventKey(event: Pick<KeyboardEvent, \"key\">, options: EventKeyOptions = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options\n\n  let { key } = event\n  key = keyMap[key] ?? key // normalize key\n\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\"\n\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key]\n  }\n\n  return key\n}\n","type PointType = \"page\" | \"client\"\n\nfunction pointFromTouch(e: TouchEvent, type: PointType = \"client\") {\n  const point = e.touches[0] || e.changedTouches[0]\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\nfunction pointFromMouse(point: MouseEvent | PointerEvent, type: PointType = \"client\") {\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\ntype AnyPointerEvent = MouseEvent | TouchEvent | PointerEvent\n\nconst isTouchEvent = (event: AnyPointerEvent): event is TouchEvent => \"touches\" in event && event.touches.length > 0\n\nexport function getEventPoint(event: AnyPointerEvent, type: PointType = \"client\") {\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type)\n}\n","const PAGE_KEYS = new Set([\"PageUp\", \"PageDown\"])\nconst ARROW_KEYS = new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"])\n\n/**\n * Determine the step factor for keyboard events\n */\nexport function getEventStep(event: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"key\" | \"shiftKey\">) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key)\n    const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.has(event.key))\n    return isSkipKey ? 10 : 1\n  }\n}\n","import type { JSX } from \"@zag-js/types\"\n\ntype NativeEvent<E> = JSX.ChangeEvent<any> extends E\n  ? InputEvent\n  : E extends JSX.SyntheticEvent<any, infer T>\n  ? T\n  : never\n\nexport function getNativeEvent<E>(event: E): NativeEvent<E> {\n  return (event as any).nativeEvent ?? event\n}\n","function clamp(value: number) {\n  return Math.max(0, Math.min(1, value))\n}\n\nexport type Point = {\n  x: number\n  y: number\n}\n\ntype PercentValueOptions = {\n  inverted?: boolean | { x?: boolean; y?: boolean }\n  dir?: \"ltr\" | \"rtl\"\n  orientation?: \"vertical\" | \"horizontal\"\n}\n\nexport function getRelativePoint(point: Point, element: HTMLElement) {\n  const { left, top, width, height } = element.getBoundingClientRect()\n\n  const offset = { x: point.x - left, y: point.y - top }\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) }\n\n  function getPercentValue(options: PercentValueOptions = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options\n\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted\n\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x\n    }\n\n    return invertY ? 1 - percent.y : percent.y\n  }\n\n  return { offset, percent, getPercentValue }\n}\n","import { addDomEvent } from \"./add-dom-event\"\n\nexport function requestPointerLock(doc: Document, fn?: (locked: boolean) => void) {\n  const body = doc.body\n\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc\n  const isLocked = () => !!doc.pointerLockElement\n\n  function onPointerChange() {\n    fn?.(isLocked())\n  }\n\n  function onPointerError(event: Event) {\n    if (isLocked()) fn?.(false)\n    console.error(\"PointerLock error occured:\", event)\n    doc.exitPointerLock()\n  }\n\n  if (!supported) return\n\n  try {\n    body.requestPointerLock()\n  } catch {}\n\n  // prettier-ignore\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ]\n\n  return () => {\n    cleanup.forEach((cleanup) => cleanup())\n    doc.exitPointerLock()\n  }\n}\n","import { disableTextSelection } from \"@zag-js/text-selection\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\n\ntype Point = {\n  x: number\n  y: number\n}\n\ntype PointerMoveHandlers = {\n  onPointerUp: VoidFunction\n  onPointerMove: (details: { point: Point; event: PointerEvent }) => void\n}\n\nexport function trackPointerMove(doc: Document, handlers: PointerMoveHandlers) {\n  const { onPointerMove, onPointerUp } = handlers\n\n  const handleMove = (event: PointerEvent) => {\n    const point = getEventPoint(event)\n\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2)\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5\n\n    if (distance < moveBuffer) return\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp()\n      return\n    }\n\n    onPointerMove({ point, event })\n  }\n\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", onPointerUp, false),\n    addDomEvent(doc, \"pointercancel\", onPointerUp, false),\n    addDomEvent(doc, \"contextmenu\", onPointerUp, false),\n    disableTextSelection({ doc }),\n  ]\n\n  return () => {\n    cleanups.forEach((cleanup) => cleanup())\n  }\n}\n","import { addDomEvent } from \"./add-dom-event\"\n\ntype ViewportSize = {\n  width: number\n  height: number\n}\n\nexport function trackVisualViewport(doc: Document, fn: (data: ViewportSize) => void) {\n  const win = doc?.defaultView || window\n\n  const onResize = () => {\n    fn?.(getViewportSize(win))\n  }\n\n  onResize()\n\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize)\n}\n\nfunction getViewportSize(win: Window): ViewportSize {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight,\n  }\n}\n","import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"tooltip\").parts(\"trigger\", \"arrow\", \"arrowTip\", \"positioner\", \"content\")\nexport const parts = anatomy.build()\n","import { dataAttr } from \"@zag-js/dom-query\"\nimport { getPlacementStyles, type PositioningOptions } from \"@zag-js/popper\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./tooltip.anatomy\"\nimport { dom } from \"./tooltip.dom\"\nimport { store } from \"./tooltip.store\"\nimport type { MachineApi, Send, State } from \"./tooltip.types\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T> {\n  const id = state.context.id\n  const hasAriaLabel = state.context.hasAriaLabel\n\n  const isOpen = state.hasTag(\"open\")\n\n  const triggerId = dom.getTriggerId(state.context)\n  const contentId = dom.getContentId(state.context)\n\n  const isDisabled = state.context.disabled\n\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.currentPlacement,\n  })\n\n  return {\n    isOpen,\n    open() {\n      send(\"OPEN\")\n    },\n    close() {\n      send(\"CLOSE\")\n    },\n    setPositioning(options: Partial<PositioningOptions> = {}) {\n      send({ type: \"SET_POSITIONING\", options })\n    },\n\n    triggerProps: normalize.button({\n      ...parts.trigger.attrs,\n      id: triggerId,\n      \"data-expanded\": dataAttr(isOpen),\n      \"data-state\": isOpen ? \"open\" : \"closed\",\n      \"aria-describedby\": isOpen ? contentId : undefined,\n      onClick() {\n        send(\"CLICK\")\n      },\n      onFocus() {\n        if (state.event.type === \"POINTER_DOWN\") return\n        send(\"FOCUS\")\n      },\n      onBlur() {\n        if (id === store.id) {\n          send(\"BLUR\")\n        }\n      },\n      onPointerDown() {\n        if (isDisabled) return\n        if (id === store.id) {\n          send(\"POINTER_DOWN\")\n        }\n      },\n      onPointerMove(event) {\n        if (isDisabled || event.pointerType === \"touch\") return\n        send(\"POINTER_MOVE\")\n      },\n      onPointerLeave() {\n        if (isDisabled) return\n        send(\"POINTER_LEAVE\")\n      },\n      onPointerCancel() {\n        if (isDisabled) return\n        send(\"POINTER_LEAVE\")\n      },\n    }),\n\n    arrowProps: normalize.element({\n      id: dom.getArrowId(state.context),\n      ...parts.arrow.attrs,\n      style: popperStyles.arrow,\n    }),\n\n    arrowTipProps: normalize.element({\n      ...parts.arrowTip.attrs,\n      style: popperStyles.arrowTip,\n    }),\n\n    positionerProps: normalize.element({\n      id: dom.getPositionerId(state.context),\n      ...parts.positioner.attrs,\n      style: popperStyles.floating,\n    }),\n\n    contentProps: normalize.element({\n      ...parts.content.attrs,\n      hidden: !isOpen,\n      \"data-state\": isOpen ? \"open\" : \"closed\",\n      role: hasAriaLabel ? undefined : \"tooltip\",\n      id: hasAriaLabel ? undefined : contentId,\n      \"data-placement\": state.context.currentPlacement,\n      onPointerEnter() {\n        send(\"CONTENT.POINTER_MOVE\")\n      },\n      onPointerLeave() {\n        send(\"CONTENT.POINTER_LEAVE\")\n      },\n      style: {\n        pointerEvents: state.context.interactive ? \"auto\" : \"none\",\n      },\n    }),\n  }\n}\n","import { createScope, getScrollParent } from \"@zag-js/dom-query\"\nimport type { MachineContext as Ctx } from \"./tooltip.types\"\n\nexport const dom = createScope({\n  getTriggerId: (ctx: Ctx) => ctx.ids?.trigger ?? `tooltip:${ctx.id}:trigger`,\n  getContentId: (ctx: Ctx) => ctx.ids?.content ?? `tooltip:${ctx.id}:content`,\n  getArrowId: (ctx: Ctx) => ctx.ids?.arrow ?? `tooltip:${ctx.id}:arrow`,\n  getPositionerId: (ctx: Ctx) => ctx.ids?.positioner ?? `tooltip:${ctx.id}:popper`,\n\n  getTriggerEl: (ctx: Ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getContentEl: (ctx: Ctx) => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: (ctx: Ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getArrowEl: (ctx: Ctx) => dom.getById(ctx, dom.getArrowId(ctx)),\n  getScrollParent: (ctx: Ctx) => getScrollParent(dom.getTriggerEl(ctx)!),\n})\n","import { proxy } from \"@zag-js/core\"\n\ntype Id = string | null\n\ntype Store = {\n  id: Id\n  prevId: Id\n  setId: (val: Id) => void\n}\n\nexport const store = proxy<Store>({\n  id: null,\n  prevId: null,\n  setId(val) {\n    this.prevId = this.id\n    this.id = val\n  },\n})\n","import { createMachine, subscribe, guards } from \"@zag-js/core\"\nimport { addDomEvent } from \"@zag-js/dom-event\"\nimport { getScrollParents, isHTMLElement, isSafari } from \"@zag-js/dom-query\"\nimport { getPlacement } from \"@zag-js/popper\"\nimport { compact } from \"@zag-js/utils\"\nimport { dom } from \"./tooltip.dom\"\nimport { store } from \"./tooltip.store\"\nimport type { MachineContext, MachineState, UserDefinedContext } from \"./tooltip.types\"\n\nconst { and, not } = guards\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"tooltip\",\n      initial: \"closed\",\n\n      context: {\n        openDelay: 1000,\n        closeDelay: 500,\n        closeOnPointerDown: true,\n        closeOnEsc: true,\n        interactive: true,\n        currentPlacement: undefined,\n        ...ctx,\n        hasPointerMoveOpened: false,\n        positioning: {\n          placement: \"bottom\",\n          ...ctx.positioning,\n        },\n      },\n\n      computed: {\n        hasAriaLabel: (ctx) => !!ctx[\"aria-label\"],\n      },\n\n      watch: {\n        disabled: [\"closeIfDisabled\"],\n        open: [\"toggleVisibility\"],\n      },\n\n      on: {\n        OPEN: \"open\",\n        CLOSE: \"closed\",\n      },\n\n      states: {\n        closed: {\n          tags: [\"closed\"],\n          entry: [\"clearGlobalId\", \"invokeOnClose\"],\n          on: {\n            FOCUS: \"open\",\n            POINTER_LEAVE: {\n              actions: [\"clearPointerMoveOpened\"],\n            },\n            POINTER_MOVE: [\n              {\n                guard: and(\"noVisibleTooltip\", not(\"hasPointerMoveOpened\")),\n                target: \"opening\",\n              },\n              {\n                guard: not(\"hasPointerMoveOpened\"),\n                target: \"open\",\n                actions: [\"setPointerMoveOpened\"],\n              },\n            ],\n          },\n        },\n\n        opening: {\n          tags: [\"closed\"],\n          activities: [\"trackScroll\", \"trackPointerlockChange\"],\n          after: {\n            OPEN_DELAY: {\n              target: \"open\",\n              actions: [\"setPointerMoveOpened\"],\n            },\n          },\n          on: {\n            POINTER_LEAVE: {\n              target: \"closed\",\n              actions: [\"clearPointerMoveOpened\"],\n            },\n            BLUR: \"closed\",\n            SCROLL: \"closed\",\n            POINTER_LOCK_CHANGE: \"closed\",\n            POINTER_DOWN: {\n              guard: \"closeOnPointerDown\",\n              target: \"closed\",\n            },\n          },\n        },\n\n        open: {\n          tags: [\"open\"],\n          activities: [\n            \"trackEscapeKey\",\n            \"trackDisabledTriggerOnSafari\",\n            \"trackScroll\",\n            \"trackPointerlockChange\",\n            \"trackPositioning\",\n          ],\n          entry: [\"setGlobalId\", \"invokeOnOpen\"],\n          on: {\n            POINTER_LEAVE: [\n              {\n                guard: \"isVisible\",\n                target: \"closing\",\n                actions: [\"clearPointerMoveOpened\"],\n              },\n              {\n                target: \"closed\",\n                actions: [\"clearPointerMoveOpened\"],\n              },\n            ],\n            BLUR: \"closed\",\n            ESCAPE: \"closed\",\n            SCROLL: \"closed\",\n            POINTER_LOCK_CHANGE: \"closed\",\n            \"CONTENT.POINTER_LEAVE\": {\n              guard: \"isInteractive\",\n              target: \"closing\",\n            },\n            POINTER_DOWN: {\n              guard: \"closeOnPointerDown\",\n              target: \"closed\",\n            },\n            CLICK: \"closed\",\n            SET_POSITIONING: {\n              actions: \"setPositioning\",\n            },\n          },\n        },\n\n        closing: {\n          tags: [\"open\"],\n          activities: [\"trackStore\", \"trackPositioning\"],\n          after: {\n            CLOSE_DELAY: \"closed\",\n          },\n          on: {\n            FORCE_CLOSE: \"closed\",\n            POINTER_MOVE: {\n              target: \"open\",\n              actions: [\"setPointerMoveOpened\"],\n            },\n            \"CONTENT.POINTER_MOVE\": {\n              guard: \"isInteractive\",\n              target: \"open\",\n            },\n          },\n        },\n      },\n    },\n    {\n      activities: {\n        trackPositioning(ctx) {\n          ctx.currentPlacement = ctx.positioning.placement\n          const getPositionerEl = () => dom.getPositionerEl(ctx)\n          return getPlacement(dom.getTriggerEl(ctx), getPositionerEl, {\n            ...ctx.positioning,\n            defer: true,\n            onComplete(data) {\n              ctx.currentPlacement = data.placement\n            },\n            onCleanup() {\n              ctx.currentPlacement = undefined\n            },\n          })\n        },\n        trackPointerlockChange(ctx, _evt, { send }) {\n          const onChange = () => send(\"POINTER_LOCK_CHANGE\")\n          return addDomEvent(dom.getDoc(ctx), \"pointerlockchange\", onChange, false)\n        },\n        trackScroll(ctx, _evt, { send }) {\n          const trigger = dom.getTriggerEl(ctx)\n          if (!trigger) return\n          const cleanups = getScrollParents(trigger).map((el) => {\n            const opts = { passive: true, capture: true } as const\n            return addDomEvent(el, \"scroll\", () => send(\"SCROLL\"), opts)\n          })\n          return () => {\n            cleanups.forEach((fn) => fn?.())\n          }\n        },\n        trackStore(ctx, _evt, { send }) {\n          return subscribe(store, () => {\n            if (store.id !== ctx.id) {\n              send(\"FORCE_CLOSE\")\n            }\n          })\n        },\n        trackDisabledTriggerOnSafari(ctx, _evt, { send }) {\n          if (!isSafari()) return\n          const doc = dom.getDoc(ctx)\n          return addDomEvent(doc, \"pointermove\", (event) => {\n            const selector = \"[data-part=trigger][data-expanded]\"\n            if (isHTMLElement(event.target) && event.target.closest(selector)) return\n            send(\"POINTER_LEAVE\")\n          })\n        },\n        trackEscapeKey(ctx, _evt, { send }) {\n          if (!ctx.closeOnEsc) return\n          const doc = dom.getDoc(ctx)\n          return addDomEvent(doc, \"keydown\", (event) => {\n            if (event.key === \"Escape\") {\n              send(\"ESCAPE\")\n            }\n          })\n        },\n      },\n      actions: {\n        setGlobalId(ctx) {\n          store.setId(ctx.id)\n        },\n        clearGlobalId(ctx) {\n          if (ctx.id === store.id) {\n            store.setId(null)\n          }\n        },\n        invokeOnOpen(ctx, evt) {\n          const omit = [\"CONTENT.POINTER_MOVE\", \"POINTER_MOVE\"]\n          if (!omit.includes(evt.type)) {\n            ctx.onOpen?.()\n          }\n        },\n        invokeOnClose(ctx) {\n          ctx.onClose?.()\n        },\n        closeIfDisabled(ctx, _evt, { send }) {\n          if (!ctx.disabled) return\n          send(\"CLOSE\")\n        },\n        setPositioning(ctx, evt) {\n          const getPositionerEl = () => dom.getPositionerEl(ctx)\n          getPlacement(dom.getTriggerEl(ctx), getPositionerEl, {\n            ...ctx.positioning,\n            ...evt.options,\n            defer: true,\n            listeners: false,\n          })\n        },\n        toggleVisibility(ctx, _evt, { send }) {\n          send({ type: ctx.open ? \"OPEN\" : \"CLOSE\", src: \"controlled\" })\n        },\n        setPointerMoveOpened(ctx) {\n          ctx.hasPointerMoveOpened = true\n        },\n        clearPointerMoveOpened(ctx) {\n          ctx.hasPointerMoveOpened = false\n        },\n      },\n      guards: {\n        closeOnPointerDown: (ctx) => ctx.closeOnPointerDown,\n        noVisibleTooltip: () => store.id === null,\n        isVisible: (ctx) => ctx.id === store.id,\n        isInteractive: (ctx) => ctx.interactive,\n        hasPointerMoveOpened: (ctx) => !!ctx.hasPointerMoveOpened,\n      },\n      delays: {\n        OPEN_DELAY: (ctx) => ctx.openDelay,\n        CLOSE_DELAY: (ctx) => ctx.closeDelay,\n      },\n    },\n  )\n}\n","import type { JSX } from \"./jsx\"\n\ntype Dict<T = any> = Record<string, T>\n\ntype Booleanish = boolean | \"true\" | \"false\"\n\ntype DataAttr = {\n  \"data-selected\"?: Booleanish\n  \"data-expanded\"?: Booleanish\n  \"data-highlighted\"?: Booleanish\n  \"data-readonly\"?: Booleanish\n  \"data-indeterminate\"?: Booleanish\n  \"data-invalid\"?: Booleanish\n  \"data-hover\"?: Booleanish\n  \"data-active\"?: Booleanish\n  \"data-focus\"?: Booleanish\n  \"data-disabled\"?: Booleanish\n  \"data-open\"?: Booleanish\n  \"data-checked\"?: Booleanish\n  \"data-pressed\"?: Booleanish\n  \"data-complete\"?: Booleanish\n  \"data-empty\"?: Booleanish\n  \"data-placeholder-shown\"?: Booleanish\n  \"data-half\"?: Booleanish\n  \"data-scope\"?: string\n\n  \"data-uid\"?: string\n  \"data-name\"?: string\n  \"data-ownedby\"?: string\n  \"data-type\"?: string\n  \"data-valuetext\"?: string\n  \"data-placement\"?: string\n  \"data-controls\"?: string\n  \"data-part\"?: string\n  \"data-label\"?: string\n  \"data-state\"?: string | null\n  \"data-value\"?: string | number\n\n  \"data-orientation\"?: \"horizontal\" | \"vertical\"\n\n  \"data-count\"?: number\n  \"data-index\"?: number\n} & {\n  [key in `data-${string}`]?: string | number | Booleanish\n}\n\nexport type PropTypes<T = Dict> = Record<\n  \"button\" | \"label\" | \"input\" | \"img\" | \"output\" | \"element\" | \"select\" | \"style\",\n  T\n>\n\nexport type NormalizeProps<T extends PropTypes> = {\n  [K in keyof T]: (props: K extends keyof JSX.IntrinsicElements ? DataAttr & JSX.IntrinsicElements[K] : never) => T[K]\n} & {\n  element(props: DataAttr & JSX.HTMLAttributes<HTMLElement>): T[\"element\"]\n  style: JSX.CSSProperties\n}\nexport function createNormalizer<T extends PropTypes>(fn: (props: Dict) => Dict): NormalizeProps<T> {\n  return new Proxy({} as any, {\n    get() {\n      return fn\n    },\n  })\n}\n","export { mergeProps } from \"@zag-js/core\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"@zag-js/core\"\nexport * from \"./normalize-props\"\nexport { Portal } from \"./portal\"\nexport type { PortalProps } from \"./portal\"\nexport * from \"./use-actor\"\nexport * from \"./use-machine\"\n","import { createNormalizer } from \"@zag-js/types\"\nimport type { HTMLAttributes, CSSProperties } from \"react\"\n\ntype WithoutRef<T> = Omit<T, \"ref\">\n\ntype ElementsWithoutRef = {\n  [K in keyof JSX.IntrinsicElements]: WithoutRef<JSX.IntrinsicElements[K]>\n}\n\nexport type PropTypes = ElementsWithoutRef & {\n  element: WithoutRef<HTMLAttributes<HTMLElement>>\n  style: CSSProperties\n}\n\nexport const normalizeProps = createNormalizer<PropTypes>((v) => v)\n","import { createElement, useReducer, useRef } from \"react\"\nimport { createPortal } from \"react-dom\"\nimport { useSafeLayoutEffect } from \"./use-layout-effect\"\n\nexport type PortalProps = {\n  children: React.ReactNode\n  target?: React.RefObject<HTMLElement>\n}\n\nexport function Portal(props: PortalProps): JSX.Element {\n  const { children, target } = props\n  const node = useRef<HTMLDivElement | null>(null)\n  const portalNode = useRef<HTMLElement | null>(null)\n  const [, forceUpdate] = useReducer((s) => s + 1, 0)\n\n  useSafeLayoutEffect(() => {\n    if (!node.current) return\n    const doc = node.current.ownerDocument\n    portalNode.current = doc.createElement(\"zag-portal\")\n    doc.body.appendChild(portalNode.current)\n\n    forceUpdate()\n\n    return () => {\n      if (portalNode.current) {\n        doc.body.removeChild(portalNode.current)\n      }\n    }\n  }, [])\n\n  const targetNode = target?.current ?? portalNode.current\n\n  if (targetNode) {\n    return createPortal(children as any, targetNode)\n  }\n\n  return createElement(\"span\", { ref: node })\n}\n","import { useEffect, useLayoutEffect } from \"react\"\n\nexport const useSafeLayoutEffect = typeof document !== \"undefined\" ? useLayoutEffect : useEffect\n","/// <reference types=\"react/experimental\" />\n\nimport { snapshot, subscribe, type Snapshot } from \"@zag-js/store\"\nimport { createProxy as createProxyToCompare, isChanged } from \"proxy-compare\"\nimport ReactExports, { useCallback, useEffect, useMemo, useRef, useSyncExternalStore } from \"react\"\n\nconst { use } = ReactExports\n\ntype Options = {\n  sync?: boolean\n}\n\nconst targetCache = new WeakMap()\n\nexport function useSnapshot<T extends object>(proxyObject: T, options?: Options): Snapshot<T> {\n  const notifyInSync = options?.sync\n  const lastSnapshot = useRef<Snapshot<T>>()\n  const lastAffected = useRef<WeakMap<object, unknown>>()\n\n  const currSnapshot = useSyncExternalStore(\n    useCallback(\n      (callback) => {\n        const unsub = subscribe(proxyObject, callback, notifyInSync)\n        callback()\n        return unsub\n      },\n      [proxyObject, notifyInSync],\n    ),\n    () => {\n      const nextSnapshot = snapshot(proxyObject, use)\n      try {\n        if (\n          lastSnapshot.current &&\n          lastAffected.current &&\n          !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, new WeakMap())\n        ) {\n          return lastSnapshot.current\n        }\n      } catch (e) {\n        // ignore if a promise or something is thrown\n      }\n      return nextSnapshot\n    },\n    () => snapshot(proxyObject, use),\n  )\n  const currAffected = new WeakMap()\n  useEffect(() => {\n    lastSnapshot.current = currSnapshot\n    lastAffected.current = currAffected\n  })\n  const proxyCache = useMemo(() => new WeakMap(), []) // per-hook proxyCache\n  return createProxyToCompare(currSnapshot, currAffected, proxyCache, targetCache)\n}\n","import type { Machine, StateMachine as S } from \"@zag-js/core\"\nimport { useSnapshot } from \"./use-snapshot\"\n\nexport function useActor<\n  TContext extends Record<string, any>,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(service: Machine<TContext, TState, TEvent>) {\n  const current = useSnapshot(service.state)\n  const typedState = current as unknown as S.State<TContext, TState, TEvent>\n  return [typedState, service.send] as const\n}\n","import { useRef } from \"react\"\n\nexport function useConstant<T>(fn: () => T): T {\n  const ref = useRef<{ v: T }>()\n  if (!ref.current) ref.current = { v: fn() }\n  return ref.current.v\n}\n","import type { MachineSrc, StateMachine as S } from \"@zag-js/core\"\nimport { useConstant } from \"./use-constant\"\nimport { useSafeLayoutEffect } from \"./use-layout-effect\"\nimport { useSnapshot } from \"./use-snapshot\"\n\nexport function useService<\n  TContext extends Record<string, any>,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(machine: MachineSrc<TContext, TState, TEvent>, options?: S.HookOptions<TContext, TState, TEvent>) {\n  const { actions, state: hydratedState, context } = options ?? {}\n\n  const service = useConstant(() => {\n    const instance = typeof machine === \"function\" ? machine() : machine\n    return context ? instance.withContext(context) : instance\n  })\n\n  useSafeLayoutEffect(() => {\n    service.start(hydratedState)\n\n    if (service.state.can(\"SETUP\")) {\n      service.send(\"SETUP\")\n    }\n\n    return () => {\n      service.stop()\n    }\n  }, [])\n\n  service.setOptions({ actions })\n  service.setContext(context)\n\n  return service\n}\n\nexport function useMachine<\n  TContext extends Record<string, any>,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(machine: MachineSrc<TContext, TState, TEvent>, options?: S.HookOptions<TContext, TState, TEvent>) {\n  const service = useService(machine, options)\n\n  const state = useSnapshot(service.state)\n  const typedState = state as unknown as S.State<TContext, TState, TEvent>\n  return [typedState, service.send, service] as const\n}\n","import React from 'react';\nimport Tooltip from '@cfx-kit/ui-components/dist/Tooltip';\n\nexport const InfoIconWithTooltip = ({\n  info,\n  size = 14,\n  children = null,\n}: {\n  info: React.ReactNode;\n  size?: number;\n  children?: React.ReactNode;\n}) => {\n  const title =\n    typeof info === 'string' ? info.split('\\n').map(i => <div>{i}</div>) : info;\n  return (\n    <div>\n      {children ? <span className=\"infoIcon-text\">{children}</span> : null}\n      <Tooltip\n        trigger={({ triggerProps }) => <div {...triggerProps}>1111</div>}\n      >\n        {title}\n      </Tooltip>\n    </div>\n  );\n};\n\n// const StyledContentWrapper = styled.span`\n//   display: inline-flex;\n//   align-items: center;\n\n//   .infoIcon-text {\n//     margin-right: 0.2857rem;\n//   }\n// `;\n"],"mappings":"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","names":["a","useEffect","parts","platform","y","i","max","offset","platform","placements","sides","side","a","placement","overflow","platform","y","x","min","max","platform","min","max","isHTMLElement","isHTMLElement","y","max","min","window","computePosition","a","data","a","callAll","isHTMLElement","arrow","transformOrigin","y","computePosition","TRACK_MEMO_SYMBOL","Symbol","GET_ORIGINAL_SYMBOL","AFFECTED_PROPERTY","ALL_OWN_KEYS_PROPERTY","newProxy","target","handler","Proxy","getProto","Object","getPrototypeOf","objectsToTrack","WeakMap","isObjectToTrack","obj","has","get","prototype","Array","isObject","x","copyTargetObject","isArray","from","descriptors","getOwnPropertyDescriptors","values","forEach","desc","configurable","create","getOriginalObject","createProxy","affected","proxyCache","targetCache","targetAndCopied","some","descriptor","writable","set","copiedTarget","handlerAndState","createProxyHandler","origObj","isTargetCopied","state","f","trackObject","recordUsage","type","key","used","Set","add","Reflect","delete","getOwnPropertyDescriptor","ownKeys","deleteProperty","isChanged","prevObj","nextObj","cache","is","hit","n","g","changed","isAllOwnKeysChanged","prevKeys","nextKeys","length","k","i","getUntracked","obj","isObjectToTrack","GET_ORIGINAL_SYMBOL","markToTrack","mark","objectsToTrack","set","proxyFunction","e","set","i","a","isDev","isObject","compact","isPlainObject","a","c","event","isObject","state","compact","options","determineDelay","delay","isDev","addDomEvent","and","not","ctx","addDomEvent","useEffect","useRef","useRef","e","useEffect","ref","useRef","machine","arrow","useEffect","jsx","jsxs","size","i"]}